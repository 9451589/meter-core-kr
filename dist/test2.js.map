{"version":3,"sources":["../src/test2.ts","../src/data.ts","../src/packets/generated/enums.ts","../src/logger/statustracker.ts","../src/logger/entityTracker.ts","../src/decompressor.ts","../src/logger/logger.ts","../src/packets/stream.ts","../src/packets/generated/structures/AbilityData.ts","../src/packets/generated/definitions/PKTAbilityChangeNotify.ts","../src/packets/generated/structures/ActiveAbility.ts","../src/packets/generated/definitions/PKTActiveAbilityNotify.ts","../src/packets/generated/definitions/PKTAddonSkillFeatureChangeNotify.ts","../src/packets/generated/definitions/PKTAuthTokenResult.ts","../src/packets/generated/definitions/PKTBlockSkillStateNotify.ts","../src/packets/generated/definitions/PKTCounterAttackNotify.ts","../src/packets/generated/definitions/PKTDeathNotify.ts","../src/packets/common/LostArkDateTime.ts","../src/packets/generated/structures/EquipItemData.ts","../src/packets/generated/definitions/PKTEquipChangeNotify.ts","../src/packets/generated/definitions/PKTEquipLifeToolChangeNotify.ts","../src/packets/generated/definitions/PKTIdentityStanceChangeNotify.ts","../src/packets/generated/definitions/PKTInitAbility.ts","../src/packets/generated/definitions/PKTInitEnv.ts","../src/packets/generated/structures/StatusEffectData.ts","../src/packets/common/ReadNBytesInt64.ts","../src/packets/generated/structures/PeriodUpdateStatData.ts","../src/packets/generated/definitions/PKTInitPC.ts","../src/packets/generated/structures/Struct_147.ts","../src/packets/generated/structures/Struct_674.ts","../src/packets/generated/structures/Struct_681.ts","../src/packets/generated/structures/Struct_626.ts","../src/packets/generated/structures/Struct_768.ts","../src/packets/generated/structures/Struct_809.ts","../src/packets/generated/structures/Struct_680.ts","../src/packets/generated/structures/BossKillData.ts","../src/packets/generated/structures/Struct_624.ts","../src/packets/generated/structures/Struct_673.ts","../src/packets/generated/structures/Struct_577.ts","../src/packets/generated/structures/ItemData.ts","../src/packets/generated/definitions/PKTInitItem.ts","../src/packets/generated/structures/CooldownData.ts","../src/packets/generated/definitions/PKTInitLocal.ts","../src/packets/generated/definitions/PKTMigrationExecute.ts","../src/packets/generated/structures/Struct_752.ts","../src/packets/common/Angle.ts","../src/packets/common/Vector3F.ts","../src/packets/generated/structures/NpcData.ts","../src/packets/generated/definitions/PKTNewNpc.ts","../src/packets/generated/definitions/PKTNewNpcSummon.ts","../src/packets/generated/structures/PCStruct.ts","../src/packets/generated/structures/TrackMoveInfo.ts","../src/packets/generated/definitions/PKTNewPC.ts","../src/packets/common/TripodLevel.ts","../src/packets/common/TripodIndex.ts","../src/packets/generated/structures/ProjectileInfo.ts","../src/packets/generated/definitions/PKTNewProjectile.ts","../src/packets/generated/structures/TrapData.ts","../src/packets/generated/definitions/PKTNewTrap.ts","../src/packets/generated/definitions/PKTParalyzationStateNotify.ts","../src/packets/generated/structures/PartyMemberData.ts","../src/packets/generated/definitions/PKTPartyInfo.ts","../src/packets/generated/definitions/PKTPartyLeaveResult.ts","../src/packets/generated/definitions/PKTPartyPassiveStatusEffectAddNotify.ts","../src/packets/generated/definitions/PKTPartyPassiveStatusEffectRemoveNotify.ts","../src/packets/generated/definitions/PKTPartyStatusEffectAddNotify.ts","../src/packets/generated/definitions/PKTPartyStatusEffectRemoveNotify.ts","../src/packets/generated/definitions/PKTPartyStatusEffectResultNotify.ts","../src/packets/generated/definitions/PKTPassiveStatusEffectAddNotify.ts","../src/packets/generated/definitions/PKTPassiveStatusEffectRemoveNotify.ts","../src/packets/generated/definitions/PKTRaidBegin.ts","../src/packets/generated/definitions/PKTRaidBossKillNotify.ts","../src/packets/generated/definitions/PKTRaidResult.ts","../src/packets/generated/structures/UnpublishObject.ts","../src/packets/generated/definitions/PKTRemoveObject.ts","../src/packets/generated/definitions/PKTSkillCancelNotify.ts","../src/packets/generated/definitions/PKTSkillCastNotify.ts","../src/packets/common/SkillMoveOptionData.ts","../src/packets/generated/structures/SkillDamageEvent.ts","../src/packets/generated/structures/SkillDamageAbnormalMoveEvent.ts","../src/packets/generated/definitions/PKTSkillDamageAbnormalMoveNotify.ts","../src/packets/generated/definitions/PKTSkillDamageNotify.ts","../src/packets/generated/definitions/PKTSkillStageNotify.ts","../src/packets/common/SkillOptionData.ts","../src/packets/generated/definitions/PKTSkillStartNotify.ts","../src/packets/generated/definitions/PKTStatChangeOriginNotify.ts","../src/packets/generated/definitions/PKTStatusEffectAddNotify.ts","../src/packets/generated/definitions/PKTStatusEffectRemoveNotify.ts","../src/packets/generated/definitions/PKTStatusEffectDurationNotify.ts","../src/packets/generated/definitions/PKTStatusEffectSyncDataNotify.ts","../src/packets/generated/definitions/PKTTriggerBossBattleStatus.ts","../src/packets/generated/definitions/PKTTriggerFinishNotify.ts","../src/packets/generated/definitions/PKTTriggerStartNotify.ts","../src/packets/generated/definitions/PKTTroopMemberUpdateMinNotify.ts","../src/packets/generated/definitions/PKTIdentityGaugeChangeNotify.ts","../src/packets/generated/definitions/PKTZoneMemberLoadStatusNotify.ts","../src/packets/generated/definitions/PKTZoneObjectUnpublishNotify.ts","../src/packets/generated/structures/ZoneStatusEffectData.ts","../src/packets/generated/definitions/PKTZoneStatusEffectAddNotify.ts","../src/packets/generated/definitions/PKTZoneStatusEffectRemoveNotify.ts","../src/packets/generated/definitions/PKTInstanceZoneEnteredNotify.ts","../src/packets/generated/definitions/PKTSkillCooldownNotify.ts","../src/packets/generated/definitions/PKTPCInspectResult.ts","../src/packets/generated/mapping.ts","../src/packets/log/codeMapping.ts","../src/packets/log/structures/AbilityData.ts","../src/packets/log/definitions/AbilityChangeNotify.ts","../src/packets/log/structures/ActiveAbility.ts","../src/packets/log/definitions/ActiveAbilityNotify.ts","../src/packets/log/definitions/AddonSkillFeatureChangeNotify.ts","../src/packets/log/definitions/BlockSkillStateNotify.ts","../src/packets/log/definitions/CounterAttackNotify.ts","../src/packets/log/definitions/DeathNotify.ts","../src/packets/log/definitions/InitAbility.ts","../src/packets/log/definitions/InitEnv.ts","../src/packets/log/structures/StatusEffectData.ts","../src/packets/log/definitions/InitPC.ts","../src/packets/log/definitions/InitLocal.ts","../src/packets/log/definitions/MigrationExecute.ts","../src/packets/log/structures/NpcData.ts","../src/packets/log/definitions/NewNpc.ts","../src/packets/log/definitions/NewNpcSummon.ts","../src/packets/log/structures/EquipItemData.ts","../src/packets/log/structures/PCStruct.ts","../src/packets/log/definitions/NewPC.ts","../src/packets/log/structures/ProjectileInfo.ts","../src/packets/log/definitions/NewProjectile.ts","../src/packets/log/definitions/ParalyzationStateNotify.ts","../src/packets/log/structures/PartyMemberData.ts","../src/packets/log/definitions/PartyInfo.ts","../src/packets/log/definitions/PartyLeaveResult.ts","../src/packets/log/definitions/PartyPassiveStatusEffectAddNotify.ts","../src/packets/log/definitions/PartyPassiveStatusEffectRemoveNotify.ts","../src/packets/log/definitions/PartyStatusEffectAddNotify.ts","../src/packets/log/definitions/PartyStatusEffectRemoveNotify.ts","../src/packets/log/definitions/PartyStatusEffectResultNotify.ts","../src/packets/log/definitions/PassiveStatusEffectAddNotify.ts","../src/packets/log/definitions/PassiveStatusEffectRemoveNotify.ts","../src/packets/log/definitions/RaidBossKillNotify.ts","../src/packets/log/definitions/RaidResult.ts","../src/packets/log/structures/UnpublishObject.ts","../src/packets/log/definitions/RemoveObject.ts","../src/packets/log/structures/SkillDamageEvent.ts","../src/packets/log/structures/SkillDamageAbnormalMoveEvent.ts","../src/packets/log/definitions/SkillDamageAbnormalMoveNotify.ts","../src/packets/log/definitions/SkillDamageNotify.ts","../src/packets/log/definitions/SkillStageNotify.ts","../src/packets/log/definitions/SkillStartNotify.ts","../src/packets/log/definitions/StatusEffectAddNotify.ts","../src/packets/log/definitions/StatusEffectRemoveNotify.ts","../src/packets/log/definitions/StatusEffectDurationNotify.ts","../src/packets/log/definitions/StatusEffectSyncDataNotify.ts","../src/packets/log/definitions/TriggerBossBattleStatus.ts","../src/packets/log/definitions/TriggerFinishNotify.ts","../src/packets/log/definitions/TriggerStartNotify.ts","../src/packets/log/definitions/TroopMemberUpdateMinNotify.ts","../src/packets/log/definitions/IdentityGaugeChangeNotify.ts","../src/packets/log/definitions/ZoneObjectUnpublishNotify.ts","../src/packets/log/structures/ZoneStatusEffectData.ts","../src/packets/log/definitions/ZoneStatusEffectAddNotify.ts","../src/packets/log/definitions/ZoneStatusEffectRemoveNotify.ts","../src/packets/log/definitions/SkillCastNotify.ts","../src/packets/log/definitions/IdentityStanceChangeNotify.ts","../src/packets/log/definitions/EquipChangeNotify.ts","../src/packets/log/definitions/EquipLifeToolChangeNotify.ts","../src/packets/log/structures/ItemData.ts","../src/packets/log/definitions/InitItem.ts","../src/packets/log/structures/BossKillData.ts","../src/packets/log/definitions/RaidBegin.ts","../src/packets/log/definitions/ZoneMemberLoadStatusNotify.ts","../src/packets/log/structures/TrapData.ts","../src/packets/log/definitions/NewTrap.ts","../src/packets/log/definitions/SkillCancelNotify.ts","../src/packets/log/definitions/InstanceZoneEnteredNotify.ts","../src/packets/log/definitions/SkillCooldownNotify.ts","../src/packets/log/definitions/PCInspectResult.ts","../src/packets/log/app/APP_StatApi.ts","../src/packets/log/logMapping.ts","../src/pkt-stream.ts","../src/logger/logEvent.ts","../src/pkt-buffer.ts","../src/packets/log/version.ts","../src/pkt-capture.ts","../src/tcp_tracker.ts","../src/ip_tracker.ts","../src/logger/parser.ts","../src/logger/gameTracker.ts","../src/logger/statapi.ts","../src/logger/partytracker.ts","../src/logger/pcidmapper.ts"],"sourcesContent":["import { createReadStream, createWriteStream, readFileSync } from \"fs\";\r\nimport { MeterData } from \"./data\";\r\nimport { Decompressor } from \"./decompressor\";\r\nimport { LiveLogger, Logger, ReplayLogger } from \"./logger/logger\";\r\nimport { PktCaptureAll, PktCaptureMode } from \"./pkt-capture\";\r\nimport { PKTStream } from \"./pkt-stream\";\r\nimport { Parser } from \"./logger/parser\";\r\nimport path from \"path\";\r\nimport { LogEvent } from \"./logger/logEvent\";\r\nimport { damagetype, hitflag, itemstoragetype, triggersignaltype } from \"./packets/generated/enums\";\r\nimport * as reads from \"./packets/generated/reads\";\r\nimport { logId } from \"./packets/log/logIds\";\r\nimport { logMapping } from \"./packets/log/logMapping\";\r\nimport * as Vector3F from \"./packets/common/Vector3F\";\r\nimport { Read } from \"./packets/stream\";\r\n\r\nimport { inspect } from \"util\";\r\nimport { mapping } from \"./packets/generated/mapping\";\r\ninspect.defaultOptions.depth = null; //Use to console log full objects for debug\r\n\r\nconst oodle_state = readFileSync(\"./meter-data/oodle_state.bin\");\r\nconst xorTable = readFileSync(\"./meter-data/xor.bin\");\r\n\r\nconst decompressor = new Decompressor(oodle_state, xorTable);\r\nconst stream = new PKTStream(decompressor);\r\n\r\nconst meterData = new MeterData();\r\nmeterData.loadDbs(\"meter-data/databases\");\r\n// meterData.processEnumData(JSON.parse(readFileSync(\"meter-data/databases/Enums.json\", \"utf-8\")));\r\n// meterData.processNpcData(JSON.parse(readFileSync(\"meter-data/databases/Npc.json\", \"utf-8\")));\r\n// meterData.processPCData(JSON.parse(readFileSync(\"meter-data/databases/PCData.json\", \"utf-8\")));\r\n// meterData.processSkillData(JSON.parse(readFileSync(\"meter-data/databases/Skill.json\", \"utf-8\")));\r\n// meterData.processSkillBuffData(JSON.parse(readFileSync(\"meter-data/databases/SkillBuff.json\", \"utf-8\")));\r\n// meterData.processSkillBuffEffectData(JSON.parse(readFileSync(\"meter-data/databases/SkillEffect.json\", \"utf-8\")));\r\n// meterData.procesStatQueryFilter(JSON.parse(readFileSync(\"meter-data/databases/StatQueryFilter.json\", \"utf-8\")));\r\n\r\nfunction logEvent(name: string, pkt: LogEvent<any>) {\r\n  //console.log(name, pkt.time, pkt.parsed);\r\n  console.log(\r\n    `${name} - ${+pkt.time} - ${JSON.stringify(pkt.parsed, (_, v) => (typeof v === \"bigint\" ? v.toString() : v))}`\r\n  );\r\n}\r\n\r\nfor (const server of [6020, 6040]) {\r\n  const capture = new PktCaptureAll(PktCaptureMode.MODE_PCAP, server);\r\n  capture.on(\"packet\", (buf) => {\r\n    try {\r\n      const badPkt = stream.read(buf);\r\n      if (badPkt === false) console.error(`bad pkt ${buf.toString(\"hex\")}`);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  });\r\n}\r\nconst testLive = true;\r\nif (testLive) {\r\n  const logger = new LiveLogger(stream, decompressor, path.resolve(\"./test3.raw\"));\r\n\r\n  const parser = new Parser(logger, meterData, \"test_client\", {\r\n    isLive: true,\r\n    resetAfterPhaseTransition: true,\r\n  });\r\n  //logger.on(\"*\", logEvent);\r\n} else {\r\n  const test = new Map();\r\n  const logger = new ReplayLogger();\r\n\r\n  let count = 0;\r\n  const m = new Map<number, string | undefined>();\r\n  const parser = new Parser(logger, meterData, \"test_client\", {\r\n    isLive: true,\r\n    resetAfterPhaseTransition: true,\r\n  });\r\n  logger.on(\"*\", (name, pkt) => {\r\n    logEvent(name, pkt);\r\n  });\r\n  logger.readLogByChunk(path.resolve(\"./test.raw\"));\r\n  logger.on(\"fileEnd\", () => {\r\n    console.log(count);\r\n    //parser.encounters;\r\n    //console.log(parser.encounters);\r\n  });\r\n}\r\n\r\nstream.on(\"*\", (data, opcode, compression, xor) => {\r\n  try {\r\n    const decomp = decompressor.decrypt(data, opcode, compression, xor);\r\n    let name = null;\r\n    var pkt = mapping.get(opcode);\r\n    if (pkt) {\r\n      [name] = pkt;\r\n    }\r\n    const fs = require('node:fs');\r\n\r\n    const content = `-> ${name ?? opcode.toString(16).padStart(4, \"0\").toUpperCase()} : ${decomp\r\n      .toString(\"hex\")\r\n      .toUpperCase()\r\n      .match(/.{2}/g)\r\n      ?.join(\" \")}\\n`;\r\n\r\n    if (name) {\r\n      //console.log(content);\r\n      // fs.appendFile(\"log1.txt\", content, (err: any) => {\r\n      //   if (err) {\r\n      //     console.log(err);\r\n      //   }\r\n      // });\r\n    }\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n});\r\n\r\nconsole.log(\"Test2: Logging\");\r\n","import { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { StatusEffectBuffTypeFlags, StatusEffectTarget, type StatusEffect, EntityState } from \"./logger/data\";\nimport {\n  addontype,\n  buffshowprioritycategory,\n  combateffectactiontype,\n  combateffectactortype,\n  combateffectconditiontype,\n  hitoption,\n  identitycategory,\n  npcgrade,\n  paramtype,\n  skillfeaturetype,\n  stattype,\n  statuseffecttargettooltiptype,\n} from \"./packets/generated/enums\";\nimport { Entity, EntityType, Player, Npc as NpcEntity } from \"./logger/entityTracker\";\nexport type Npc = {\n  id: number;\n  name: string;\n  grade: keyof typeof npcgrade;\n  type: string;\n  pushimmune: boolean;\n};\n\nexport type Skill = {\n  id: number;\n  name: string;\n  desc: string;\n  classid: number;\n  icon: string;\n  identitycategory?: keyof typeof identitycategory;\n  groups?: number[];\n  summonids?: number[];\n  summonsourceskill?: number;\n  sourceskill?: number;\n};\n\nexport type SkillBuff = {\n  id: number;\n  name: string;\n  desc: string;\n  icon: string;\n  iconshowtype: string; // statuseffecticonshowtype\n  duration: number;\n  category: \"buff\" | \"debuff\";\n  type: string; // statuseffecttype\n  statuseffectvalues?: number[];\n  buffcategory: keyof typeof buffshowprioritycategory;\n  target: keyof typeof statuseffecttargettooltiptype;\n  uniquegroup: number;\n  overlapFlag: number;\n  passiveoption: PassiveOption[];\n  sourceskill?: number;\n  setname?: string; // set nicename when buffcategory === \"set\"\n};\n\nexport type SkillFeature = Map<number, SkillFeatureLevelData>;\nexport type SkillFeatureLevelData = {\n  key: number;\n  name: string;\n  entries: SkillFeatureOption[];\n};\nexport type SkillFeatureOption = {\n  type: keyof typeof skillfeaturetype;\n  level: number;\n  paramtype: keyof typeof paramtype;\n  params: number[];\n};\n\nexport type PassiveOption = {\n  type: keyof typeof addontype; //addontype\n  keystat: keyof typeof stattype; //stattype\n  keyindex: number;\n  value: number;\n};\n\nexport type CombatEffect = {\n  id: number;\n  effects: CombatEffectDetail[];\n};\nexport type CombatEffectDetail = {\n  ratio: number;\n  cooldown: number;\n  conditions: CombatEffectCondition[];\n  actions: CombatEffectAction[];\n};\nexport type CombatEffectCondition = {\n  type: keyof typeof combateffectconditiontype; //combateffectconditiontype\n  actor: keyof typeof combateffectactortype; //combateffectactortype\n  arg: number;\n};\nexport type CombatEffectAction = {\n  type: keyof typeof combateffectactiontype; //combateffectactiontype\n  actor: keyof typeof combateffectactortype; //combateffectactortype\n  args: number[];\n};\n\nexport type SkillEffect = {\n  id: number;\n  comment: string;\n  stagger: number;\n  sourceskill: number;\n  directionalmask: number;\n  itemname?: string;\n  itemdesc?: string;\n  icon?: string;\n  itemcategory?: string;\n};\n\nexport type Esther = {\n  name: string;\n  icon: string;\n  skills: number[];\n  npcs: number[];\n};\nexport type ItemSetData = { setname: string; level: number };\nexport type ItemSet = {\n  items: Map<number, ItemSetData>;\n  seteffects: Map<string, ItemSetLevel>;\n};\nexport type ItemSetLevel = Map<number, ItemSetCount>;\nexport type ItemSetCount = Map<number, { desc: string; options: PassiveOption[] }>;\nexport type CombatEffectConditionData = {\n  effect: CombatEffectDetail;\n  self?: Entity;\n  target?: Entity;\n  caster?: Entity | undefined;\n  skill?: Skill | undefined;\n  hitOption?: hitoption;\n  targetCount?: number;\n};\n\nexport type StatQueryFilter = {\n  zone: Set<number>;\n  raid: Set<number>;\n};\n\nexport class MeterData {\n  dbPath: string = \"\";\n  modulePath: string;\n\n  enums: Map<string, Map<string, string>>;\n  npc: Map<number, Npc>;\n  PCData: Map<number, string>;\n  skill: Map<number, Skill>;\n  skillBuff: Map<number, SkillBuff>;\n  skillEffect: Map<number, SkillEffect>;\n  skillFeature: Map<number, SkillFeature>;\n  combatEffect: Map<number, CombatEffect>;\n  esther: Esther[];\n  itemSet: ItemSet;\n  statQueryFilter: StatQueryFilter;\n\n  constructor(meterDataPath: string = \"./meter-core/data\") {\n    this.modulePath = meterDataPath;\n    this.enums = new Map();\n    this.npc = new Map();\n    this.PCData = new Map();\n    this.skill = new Map();\n    this.skillBuff = new Map();\n    this.skillEffect = new Map();\n    this.skillFeature = new Map();\n    this.combatEffect = new Map();\n    this.esther = [];\n    this.itemSet = { items: new Map(), seteffects: new Map() };\n    this.statQueryFilter = { zone: new Set(), raid: new Set() };\n  }\n\n  processEnumData(data: { [key: string]: { [key: string]: string } }) {\n    for (const [ename, edata] of Object.entries(data)) {\n      const en = new Map();\n      for (const [k, v] of Object.entries(edata)) en.set(k, v);\n      this.enums.set(ename, en);\n    }\n  }\n\n  processNpcData(data: { [key: string]: Npc }) {\n    for (const npc of Object.values(data)) {\n      this.npc.set(npc.id, npc);\n    }\n  }\n\n  processPCData(data: { [key: string]: string }) {\n    for (const [k, v] of Object.entries(data)) {\n      this.PCData.set(parseInt(k), v);\n    }\n  }\n\n  processSkillData(data: { [key: string]: Skill }) {\n    for (const skill of Object.values(data)) {\n      this.skill.set(skill.id, skill);\n    }\n  }\n\n  processSkillBuffData(data: { [key: string]: SkillBuff }) {\n    for (const skillBuff of Object.values(data)) {\n      this.skillBuff.set(skillBuff.id, skillBuff);\n    }\n  }\n\n  processSkillBuffEffectData(data: { [key: string]: SkillEffect }) {\n    for (const skillEffect of Object.values(data)) {\n      this.skillEffect.set(skillEffect.id, skillEffect);\n    }\n  }\n  processSkillFeature(data: {\n    [skillid: string]: {\n      skillid: number;\n      tripods: { [index: string]: { key: number; name: string; entries: SkillFeatureOption[] } };\n    };\n  }) {\n    for (const skillFeature of Object.values(data)) {\n      const m = new Map<number, SkillFeatureLevelData>();\n      for (const levelData of Object.values(skillFeature.tripods)) {\n        m.set(levelData.key, levelData);\n      }\n      this.skillFeature.set(skillFeature.skillid, m);\n    }\n  }\n  processCombatEffectData(data: { [key: string]: CombatEffect }) {\n    for (const combatEffect of Object.values(data)) {\n      this.combatEffect.set(combatEffect.id, combatEffect);\n    }\n  }\n  processEsther(data: Esther[]) {\n    this.esther = Object.values(data);\n  }\n  processItemSet(data: {\n    [setName: string]: {\n      [setLevel: string]: {\n        itemids: number[];\n        value: {\n          [setCount: string]: {\n            desc: string;\n            options: PassiveOption[];\n          };\n        };\n      };\n    };\n  }) {\n    for (const [setName, setNameData] of Object.entries(data)) {\n      const m: ItemSetLevel = new Map();\n      for (const [level, setLevelData] of Object.entries(setNameData)) {\n        const m2: ItemSetCount = new Map();\n        for (const [count, setCountData] of Object.entries(setLevelData.value)) {\n          m2.set(parseInt(count), setCountData);\n        }\n        m.set(parseInt(level), m2);\n        for (const itemid of Object.values(setLevelData.itemids)) {\n          this.itemSet.items.set(itemid, { setname: setName, level: parseInt(level) });\n        }\n      }\n      this.itemSet.seteffects.set(setName, m);\n    }\n  }\n\n  procesStatQueryFilter(data: { zone: number[]; raid: number[] }) {\n    this.statQueryFilter.zone = new Set(data.zone);\n    this.statQueryFilter.raid = new Set(data.raid);\n  }\n\n  getNpcName(id: number) {\n    return this.npc.get(id)?.name || \"\";\n  }\n\n  getClassName(id: number) {\n    return this.PCData.get(id) || \"\";\n  }\n\n  getSkillName(id: number) {\n    return this.skill.get(id)?.name || \"\";\n  }\n\n  getSkillClassId(id: number) {\n    return this.skill.get(id)?.classid || 0;\n  }\n\n  getSkillEffectComment(id: number) {\n    return this.skillEffect.get(id)?.comment || \"\";\n  }\n  getSkillEffectDirectionalMask(id: number) {\n    return this.skillEffect.get(id)?.directionalmask || 0;\n  }\n\n  getSkillEsther(skillId: number): Esther | undefined {\n    for (const esther of this.esther) {\n      if (esther.skills.includes(skillId)) return esther;\n    }\n    return;\n  }\n  getNpcEsther(npcId: number): Esther | undefined {\n    for (const esther of this.esther) {\n      if (esther.npcs.includes(npcId)) return esther;\n    }\n    return;\n  }\n\n  getStatusEffectHeaderData(buffId: number) {\n    const buff = this.skillBuff.get(buffId);\n    if (!buff || buff.iconshowtype === \"none\") return;\n    // Category override\n    let buffcategory;\n    if (buff.buffcategory === \"ability\" && [501, 502, 503, 504, 505].includes(buff.uniquegroup)) {\n      buffcategory = \"dropsofether\";\n    } else {\n      buffcategory = buff.buffcategory;\n    }\n    const statusEffect: StatusEffect = {\n      target:\n        buff.target === \"none\"\n          ? StatusEffectTarget.OTHER\n          : buff.target === \"self\"\n          ? StatusEffectTarget.SELF\n          : StatusEffectTarget.PARTY, // self+party\n      category: buff.category,\n      buffcategory,\n      bufftype: this.getStatusEffectBuffTypeFlags(buff),\n      uniquegroup: buff.uniquegroup,\n      source: {\n        name: buff.name,\n        desc: buff.desc,\n        icon: buff.icon,\n      },\n    };\n    if (buffcategory === \"classskill\" || buffcategory === \"identity\") {\n      let buffSourceSkill;\n      if (buff.sourceskill) {\n        // Source skill from db\n        buffSourceSkill = this.skill.get(buff.sourceskill);\n        if (buffSourceSkill) statusEffect.source.skill = buffSourceSkill;\n      } else {\n        // Try to guess\n        //const skillId = Math.floor(buff.uniquegroup / 100) * 10;\n        const skillId = Math.floor(buffId / 100) * 10;\n        buffSourceSkill = this.skill.get(skillId);\n        if (!buffSourceSkill) {\n          const skillId = Math.floor(buff.uniquegroup / 100) * 10;\n          buffSourceSkill = this.skill.get(skillId);\n        }\n        if (buffSourceSkill) statusEffect.source.skill = buffSourceSkill;\n      }\n      if (buffSourceSkill) statusEffect.source.skill = buffSourceSkill;\n    } else if (buffcategory === \"ability\" && buff.uniquegroup !== 0) {\n      let buffSourceSkill;\n      if (buff.sourceskill) {\n        // Source skill from db\n        buffSourceSkill = this.skill.get(buff.sourceskill);\n        if (buffSourceSkill) statusEffect.source.skill = buffSourceSkill;\n      } else {\n        // Try to guess\n        //const skillId = Math.floor(buff.uniquegroup / 100) * 10;\n        const skillId = Math.floor(buffId / 100) * 10;\n        buffSourceSkill = this.skill.get(skillId);\n        if (!buffSourceSkill) {\n          const skillId = Math.floor(buff.uniquegroup / 100) * 10;\n          buffSourceSkill = this.skill.get(skillId);\n        }\n      }\n      if (buffSourceSkill) statusEffect.source.skill = buffSourceSkill;\n    } else if (buffcategory === \"set\" && buff.setname) {\n      statusEffect.source.setname = buff.setname;\n    }\n\n    return statusEffect;\n  }\n  getStatusEffectBuffTypeFlags(buff: SkillBuff) {\n    let bufftype = StatusEffectBuffTypeFlags.NONE;\n\n    // Extract type from Buff type\n    //TODO check & apply condition of buffs\n    if (\n      [\n        \"weaken_defense\",\n        \"weaken_resistance\",\n        \"skill_damage_amplify\",\n        \"beattacked_damage_amplify\",\n        \"skill_damage_amplify_attack\",\n        \"directional_attack_amplify\",\n        \"instant_stat_amplify\",\n        \"attack_power_amplify\",\n        \"instant_stat_amplify_by_contents\",\n      ].includes(buff.type)\n    ) {\n      bufftype |= StatusEffectBuffTypeFlags.DMG;\n    } else if ([\"move_speed_down\", \"all_speed_down\"].includes(buff.type)) {\n      bufftype |= StatusEffectBuffTypeFlags.MOVESPEED;\n    } else if ([\"reset_cooldown\"].includes(buff.type)) {\n      bufftype |= StatusEffectBuffTypeFlags.COOLDOWN;\n    } else if ([\"change_ai_point\", \"ai_point_amplify\"].includes(buff.type)) {\n      bufftype |= StatusEffectBuffTypeFlags.STAGGER;\n    } else if ([\"increase_identity_gauge\"].includes(buff.type)) {\n      bufftype |= StatusEffectBuffTypeFlags.RESOURCE;\n    } /*\n    else if ([\"aura\"].includes(buff.type)) {\n      //TODO: look into ValueA to get the buff applied by the aura (probably useless as we'll get the buff itself)\n    }*/\n\n    // Extract type from passive options\n    buff.passiveoption.forEach((option) => {\n      const addon = addontype[option.type];\n      if (option.type === \"stat\") {\n        const stat = stattype[option.keystat];\n        if ([stattype.mastery, stattype.mastery_x, stattype.paralyzation_point_rate].includes(stat)) {\n          bufftype |= StatusEffectBuffTypeFlags.STAGGER;\n        }\n        if ([stattype.rapidity, stattype.rapidity_x, stattype.cooldown_reduction].includes(stat)) {\n          bufftype |= StatusEffectBuffTypeFlags.COOLDOWN;\n        }\n        if (\n          [\n            stattype.max_mp,\n            stattype.max_mp_x,\n            stattype.max_mp_x_x,\n            stattype.normal_mp_recovery,\n            stattype.combat_mp_recovery,\n            stattype.normal_mp_recovery_rate,\n            stattype.combat_mp_recovery_rate,\n            stattype.resource_recovery_rate,\n          ].includes(stat)\n        ) {\n          bufftype |= StatusEffectBuffTypeFlags.RESOURCE;\n        }\n        if (\n          [\n            stattype.con,\n            stattype.con_x,\n            stattype.max_hp,\n            stattype.max_hp_x,\n            stattype.max_hp_x_x,\n            stattype.normal_hp_recovery,\n            stattype.combat_hp_recovery,\n            stattype.normal_hp_recovery_rate,\n            stattype.combat_hp_recovery_rate,\n            stattype.self_recovery_rate,\n            stattype.drain_hp_dam_rate,\n            stattype.vitality,\n          ].includes(stat)\n        ) {\n          bufftype |= StatusEffectBuffTypeFlags.HP;\n        }\n        if (\n          (stattype.def <= stat && stat <= stattype.magical_inc_rate) ||\n          [stattype.endurance, stattype.endurance_x].includes(stat)\n        ) {\n          if ((buff.category === \"buff\" && option.value >= 0) || (buff.category === \"debuff\" && option.value <= 0)) {\n            bufftype |= StatusEffectBuffTypeFlags.DMG;\n          } else bufftype |= StatusEffectBuffTypeFlags.DEFENSE;\n        }\n        if (stattype.move_speed <= stat && stat <= stattype.vehicle_move_speed_rate) {\n          bufftype |= StatusEffectBuffTypeFlags.MOVESPEED;\n        }\n        if (\n          [stattype.attack_speed, stattype.attack_speed_rate, stattype.rapidity, stattype.rapidity_x].includes(stat)\n        ) {\n          bufftype |= StatusEffectBuffTypeFlags.ATKSPEED;\n        }\n        if ([stattype.critical_hit_rate, stattype.criticalhit, stattype.criticalhit_x].includes(stat)) {\n          bufftype |= StatusEffectBuffTypeFlags.CRIT;\n        }\n        if (\n          (stattype.attack_power_sub_rate_1 <= stat && stat <= stattype.skill_damage_sub_rate_2) ||\n          (stattype.fire_dam_rate <= stat && stat <= stattype.elements_dam_rate) ||\n          [\n            stattype.str,\n            stattype.agi,\n            stattype.int,\n            stattype.str_x,\n            stattype.agi_x,\n            stattype.int_x,\n            stattype.char_attack_dam,\n            stattype.attack_power_rate,\n            stattype.skill_damage_rate,\n            stattype.attack_power_rate_x,\n            stattype.skill_damage_rate_x,\n            stattype.hit_rate,\n            stattype.dodge_rate,\n            stattype.critical_dam_rate,\n            stattype.awakening_dam_rate,\n            stattype.attack_power_addend,\n            stattype.weapon_dam,\n          ].includes(stat)\n        ) {\n          if ((buff.category === \"buff\" && option.value >= 0) || (buff.category === \"debuff\" && option.value <= 0)) {\n            bufftype |= StatusEffectBuffTypeFlags.DMG;\n          } else bufftype |= StatusEffectBuffTypeFlags.DEFENSE;\n        }\n      } else if (addontype.skill_critical_ratio === addon) {\n        bufftype |= StatusEffectBuffTypeFlags.CRIT;\n      } else if (\n        [\n          addontype.skill_damage,\n          addontype.class_option,\n          addontype.skill_group_damage,\n          addontype.skill_critical_damage,\n          addontype.skill_penetration,\n        ].includes(addon)\n      ) {\n        if ((buff.category === \"buff\" && option.value >= 0) || (buff.category === \"debuff\" && option.value <= 0)) {\n          bufftype |= StatusEffectBuffTypeFlags.DMG;\n        } else bufftype |= StatusEffectBuffTypeFlags.DEFENSE;\n      } else if ([addontype.skill_cooldown_reduction, addontype.skill_group_cooldown_reduction].includes(addon)) {\n        bufftype |= StatusEffectBuffTypeFlags.COOLDOWN;\n      } else if ([addontype.skill_mana_reduction, addontype.mana_reduction].includes(addon)) {\n        bufftype |= StatusEffectBuffTypeFlags.RESOURCE;\n      } else if (addontype.combat_effect === addon) {\n        // Extract type from combat_effect\n        const combatEffect = this.combatEffect.get(option.keyindex);\n        if (!combatEffect) return;\n        combatEffect.effects.forEach((effect) => {\n          //TODO: evaluate conditions ? or maybe it should be done on meter core & remove those buffs\n          effect.actions.forEach((action) => {\n            const actionType = combateffectactiontype[action.type];\n            if (\n              [\n                combateffectactiontype.modify_damage,\n                combateffectactiontype.modify_final_damage,\n                combateffectactiontype.modify_critical_multiplier,\n                combateffectactiontype.modify_penetration,\n                combateffectactiontype.modify_penetration_when_critical,\n                combateffectactiontype.modify_penetration_addend,\n                combateffectactiontype.modify_penetration_addend_when_critical,\n                combateffectactiontype.modify_damage_shield_multiplier,\n              ].includes(actionType)\n            ) {\n              bufftype |= StatusEffectBuffTypeFlags.DMG;\n            } else if (combateffectactiontype.modify_critical_ratio === actionType) {\n              bufftype |= StatusEffectBuffTypeFlags.CRIT;\n            }\n          });\n        });\n      }\n    });\n    return bufftype;\n  }\n  getStatPairMap(statpair: { statType: number; value: bigint }[]) {\n    //TODO: use a \"Common\" packet for statpair parsing\n    const map = new Map<stattype, bigint>();\n    statpair.forEach((pair) => {\n      map.set(pair.statType, pair.value);\n    });\n    return map;\n  }\n  isCombatEffectConditionsValid({\n    effect,\n    self,\n    target,\n    caster,\n    skill,\n    hitOption,\n    targetCount,\n  }: CombatEffectConditionData): boolean {\n    let conditionValid = true;\n    effect.conditions.forEach((condition) => {\n      if (!conditionValid) return;\n      const actor = combateffectactortype[condition.actor];\n      switch (combateffectconditiontype[condition.type]) {\n        case combateffectconditiontype.target_count:\n          if (!targetCount || targetCount !== condition.arg) conditionValid = false;\n          break;\n        case combateffectconditiontype.current_skill:\n          if (!skill || skill.id === condition.arg) conditionValid = false;\n          break;\n        case combateffectconditiontype.pc:\n          if (actor === combateffectactortype.self) {\n            if (!self || self.entityType !== EntityType.Player) conditionValid = false;\n          } else if (actor === combateffectactortype.target) {\n            if (!target || target.entityType !== EntityType.Player) conditionValid = false;\n          } else if (actor === combateffectactortype.caster) {\n            if (!caster || caster.entityType !== EntityType.Player) conditionValid = false;\n          } else {\n            conditionValid = false;\n          }\n          break;\n        case combateffectconditiontype.skill_identity_category:\n          if (!skill || !skill.identitycategory || identitycategory[skill.identitycategory] != condition.arg)\n            conditionValid = false;\n          break;\n        //S_ImmuneNotify, S_ImmuneStatusNotify\n        /**\n         * \"movetype\" enum in AbnormalMoveNotify\n         * \"movetype\" & \"MoveOptionData\" in SkillDamageAbnormalMoveNotify\n         * \"ImmuneNotify\" takes an effectId, mby it's smthing else ?\n         * \"ImmuneStatusNotify\" has ImmuneData with {DebuffImmuneList, AbnormalStatusImmuneList, StatusEffectTypeImmuneList} each of those have Type/Value\n         */\n        case combateffectconditiontype.abnormal_move_immune:\n          //\"Push immune foes\", usually tripod \"Weak Point Detection\"\n          if (\n            !target ||\n            ![EntityType.Npc, EntityType.Summon].includes(target.entityType) ||\n            !(target as NpcEntity).pushimmune\n          )\n            conditionValid = false;\n          break;\n        case combateffectconditiontype.abnormal_move_all:\n          //TODO: implement abnormal move tracking (with expiration & stuff)\n          // Only useful for 250841 (Blade's Death Sentence / Confirmed Kill tripod)\n          conditionValid = false;\n          break;\n        case combateffectconditiontype.abnormal_move:\n          //TODO: implement abnormal move tracking (with expiration & stuff)\n          // Only useful for 250851 (Blade's Death Sentence / Ruthless tripod)\n          conditionValid = false;\n          break;\n        case combateffectconditiontype.abnormal_status:\n          //TODO: implement abnormal move tracking (with expiration & stuff)\n          // Only useful for 351308 (Machinist's Annihilation Mode / Cross Fire tripod)\n          conditionValid = false;\n          break;\n        case combateffectconditiontype.current_skill_group:\n          if (!skill || !skill.groups || !skill.groups.includes(condition.arg)) conditionValid = false;\n          break;\n        case combateffectconditiontype.hp_less:\n          if (actor === combateffectactortype.self) {\n            if (\n              !self ||\n              Number((self.stats.get(stattype.hp) ?? 0n) / (self.stats.get(stattype.max_hp) ?? 0n)) >=\n                condition.arg / 100\n            )\n              conditionValid = false;\n          } else if (actor === combateffectactortype.target) {\n            if (\n              !target ||\n              Number((target.stats.get(stattype.hp) ?? 0n) / (target.stats.get(stattype.max_hp) ?? 0n)) >=\n                condition.arg / 100\n            )\n              conditionValid = false;\n          } else if (actor === combateffectactortype.caster) {\n            if (\n              !caster ||\n              Number((caster.stats.get(stattype.hp) ?? 0n) / (caster.stats.get(stattype.max_hp) ?? 0n)) >=\n                condition.arg / 100\n            )\n              conditionValid = false;\n          } else {\n            conditionValid = false;\n            break;\n          }\n          break;\n        case combateffectconditiontype.npc_scaled_level_less:\n          if (actor === combateffectactortype.target) {\n            if (target && [EntityType.Npc, EntityType.Summon].includes(target.entityType)) {\n              if ((target as NpcEntity).balanceLevel > condition.arg) conditionValid = false;\n            } else conditionValid = false;\n          } else {\n            conditionValid = false;\n          }\n          break;\n        case combateffectconditiontype.npc_grade_less:\n          if (actor === combateffectactortype.target) {\n            if (target && [EntityType.Npc, EntityType.Summon].includes(target.entityType)) {\n              const grade = npcgrade[(target as NpcEntity).grade];\n              if (!grade || grade > condition.arg) conditionValid = false;\n            } else conditionValid = false;\n          } else {\n            conditionValid = false;\n          }\n          break;\n        case combateffectconditiontype.npc_grade_greater:\n          if (actor === combateffectactortype.target) {\n            if (target && [EntityType.Npc, EntityType.Summon].includes(target.entityType)) {\n              const grade = npcgrade[(target as NpcEntity).grade];\n              if (!grade || grade < condition.arg) conditionValid = false;\n            } else conditionValid = false;\n          } else {\n            conditionValid = false;\n          }\n          break;\n        case combateffectconditiontype.identity_stance:\n          if (actor === combateffectactortype.self) {\n            if (!self || self.entityType !== EntityType.Player || (self as Player).stance !== condition.arg)\n              conditionValid = false;\n          } else {\n            conditionValid = false;\n          }\n          break;\n        case combateffectconditiontype.directional_attack:\n          if (!hitOption || ((hitOption + 1) & condition.arg) === 0) conditionValid = false;\n          break;\n        default:\n          // The condition isn't handled, invalidate condition\n          conditionValid = false;\n          break;\n      }\n    });\n    return conditionValid;\n  }\n  isSupportClassId(id: number) {\n    return id === 105 || id === 204 || id === 602;\n  }\n  isBattleItem(id: number, type?: \"attack\" | \"buff\" | \"function\") {\n    const itemcategory = this.skillEffect.get(id)?.itemcategory;\n    switch (type) {\n      case \"attack\":\n        return itemcategory === \"useup_battle_item_common_attack\";\n      case \"buff\":\n        return itemcategory === \"useup_battle_item_common_buff\";\n      case \"function\":\n        return itemcategory === \"useup_battle_item_common_function\";\n      default:\n        return typeof itemcategory === \"string\";\n    }\n  }\n\n  getBattleItemName(id: number) {\n    return this.skillEffect.get(id)?.itemname || \"\";\n  }\n  loadDbs(basePath: string) {\n    this.dbPath = basePath;\n\n    this.processEnumData(JSON.parse(readFileSync(join(basePath, \"Enums.json\"), \"utf-8\")));\n    this.processNpcData(JSON.parse(readFileSync(join(basePath, \"Npc.json\"), \"utf-8\")));\n    this.processPCData(JSON.parse(readFileSync(join(basePath, \"PCData.json\"), \"utf-8\")));\n    this.processSkillData(JSON.parse(readFileSync(join(basePath, \"Skill.json\"), \"utf-8\")));\n    this.processSkillBuffData(JSON.parse(readFileSync(join(basePath, \"SkillBuff.json\"), \"utf-8\")));\n    this.processSkillBuffEffectData(JSON.parse(readFileSync(join(basePath, \"SkillEffect.json\"), \"utf-8\")));\n    this.processSkillFeature(JSON.parse(readFileSync(join(basePath, \"SkillFeature.json\"), \"utf-8\")));\n    this.processCombatEffectData(JSON.parse(readFileSync(join(basePath, \"CombatEffect.json\"), \"utf-8\")));\n    this.processEsther(JSON.parse(readFileSync(join(basePath, \"Esther.json\"), \"utf-8\")));\n    this.processItemSet(JSON.parse(readFileSync(join(basePath, \"ItemSet.json\"), \"utf-8\")));\n    this.procesStatQueryFilter(JSON.parse(readFileSync(join(basePath, \"StatQueryFilter.json\"), \"utf-8\")));\n  }\n}\n","export enum abilityfeaturetype {\n  none = 0,\n  potion_junkie = 1,\n  ruthless = 2,\n  spirit_absorption = 3,\n  ether_junkie = 4,\n  steady_state = 5,\n  amputation_master = 6,\n  sparkle = 7,\n  strong_back = 8,\n  living_expert = 9,\n  grudge = 10,\n  evasion_expert = 11,\n  super_charge = 12,\n  stun_immunity = 13,\n  indomitable_will = 14,\n  fugitive = 15,\n  identity_berserker_madness = 16,\n  identity_battle_master_bubble = 17,\n  identity_devil_hunter_weapon = 18,\n  identity_blaster_overhaul = 19,\n  lucky_monster_killer = 20,\n  harmony = 21,\n  ether_boy = 22,\n  money_explosion = 23,\n  glutton = 24,\n  secret_map = 25,\n  near_death_experience = 26,\n  matt_critical = 27,\n  heavy_punch = 28,\n  stone_immunity = 29,\n  freeze_immunity = 30,\n  silence_immunity = 31,\n  earthquake_immunity = 32,\n  fear_immunity = 33,\n  burn_immunity = 34,\n  slow_immunity = 35,\n  penetration_master = 36,\n  blow_master = 37,\n  life_dynamite = 38,\n  life_miners_instinct = 39,\n  life_luckyday = 40,\n  life_golden_fish = 41,\n  life_fishing_net_expert = 42,\n  life_lumbering_tool_master = 43,\n  life_lumbering_extra_huge = 44,\n  life_lumbering_sapling = 45,\n  life_four_leafed_clover = 46,\n  life_bug_master = 47,\n  life_old_wild_ginseng = 48,\n  life_hunting_pro = 49,\n  life_butcher = 50,\n  life_hot_spot = 51,\n  life_delicate_digging = 52,\n  life_concentration = 53,\n  life_high_frequency = 54,\n  life_pickaxe_tierup = 55,\n  life_moonlight_penaltyoff = 56,\n  life_fastbomb = 57,\n  life_fishingrod_tierup = 58,\n  life_double_point = 59,\n  life_golden_bait = 60,\n  life_axe_tierup = 61,\n  life_treekick = 62,\n  life_glove_tierup = 63,\n  life_faker_touch = 64,\n  life_machete_tierup = 65,\n  life_heavypoison = 66,\n  life_goldenrabbit = 67,\n  life_shovel_tierup = 68,\n  life_treasurehenter = 69,\n  life_protamer = 70,\n  electrocution_immunity = 71,\n  vermin_immunity = 72,\n  sleep_immunity = 73,\n  confinement_immunity = 74,\n  bleeding_immunity = 75,\n  poisoning_immunity = 76,\n  curse_immunity = 77,\n  slowness_immunity = 78,\n  disarming_immunity = 79,\n  all_speed_down_immunity = 80,\n  darkness_immunity = 81,\n  chill_immunity = 82,\n  identity_berserker_rush_up = 83,\n  identity_battle_master_original_intention = 84,\n  identity_infighter_vigor_master = 85,\n  identity_infighter_shock_regen = 86,\n  identity_devil_hunter_hand_gunner = 87,\n  identity_blaster_free_bomb_ardment = 88,\n  identity_bard_sweet_song = 89,\n  identity_bard_urgent_rescue = 90,\n  identity_destroyer_angry_hammer = 91,\n  identity_destroyer_gravity_up = 92,\n  identity_summoner_senior = 93,\n  identity_summoner_ancient_energy = 94,\n  identity_arcana_empress_card = 95,\n  identity_arcana_emperor_card = 96,\n  emergency_stantup = 97,\n  outsider = 98,\n  telescope = 99,\n  identity_warlord_light_sheild = 100,\n  identity_warlord_lonely_knight = 101,\n  tenacity = 102,\n  grinding_glove = 103,\n  shield_penetration = 104,\n  strength_master = 105,\n  protection_goddess = 106,\n  heavy_armor = 107,\n  explosion_master = 108,\n  upgrade_shield = 109,\n  necromancer = 110,\n  first_critical = 111,\n  broken_bone = 112,\n  thunder_fury = 113,\n  cursed_toy = 114,\n  gladiator = 115,\n  backstab_master = 116,\n  ether_evaporation = 117,\n  mana_flow = 118,\n  double_jump = 119,\n  barricade = 120,\n  troop_leader = 121,\n  awakening = 122,\n  another_silverhawk = 123,\n  handling_silverhawk = 124,\n  released_qi = 125,\n  power_qi = 126,\n  vf_cruel_delete__ = 127,\n  vf_balance_hit_delete__ = 128,\n  vf_solidarity_delete__ = 129,\n  vf_job_hunter_delete__ = 130,\n  vf_hardness_delete__ = 131,\n  vf_warmonger_delete__ = 132,\n  vf_elemental_effect_delete__ = 133,\n  vf_quick_stand_delete__ = 134,\n  vf_swift_delete__ = 135,\n  vf_counter_chance_delete__ = 136,\n  vf_bubble_fury_delete__ = 137,\n  vf_madness_follower_delete__ = 138,\n  vf_fury_train_delete__ = 139,\n  vf_guardian_cape_delete__ = 140,\n  vf_counter_attack_delete__ = 141,\n  vf_endurance_delete__ = 142,\n  vf_fury_stimulus_delete__ = 143,\n  vf_giant_blood_delete__ = 144,\n  vf_tough_skin_delete__ = 145,\n  vf_blood_thirsh_delete__ = 146,\n  vf_blood_warrior_delete__ = 147,\n  vf_emergency_heal_delete__ = 148,\n  vf_chaser_delete__ = 149,\n  vf_strong_hit_delete__ = 150,\n  vf_sharp_focus_delete__ = 151,\n  vf_blood_fury_delete__ = 152,\n  vf_frenzy_delete__ = 153,\n  vf_impregnability_delete__ = 154,\n  vf_defense_postures_delete__ = 155,\n  vf_iron_shield_delete__ = 156,\n  vf_magic_shield_delete__ = 157,\n  vf_endurance_heal_delete__ = 158,\n  vf_recover_delete__ = 159,\n  vf_battle_commander_delete__ = 160,\n  vf_punish_delete__ = 161,\n  vf_iron_wall_delete__ = 162,\n  vf_increment_gravity_delete__ = 163,\n  vf_reverse_gravity_delete__ = 164,\n  vf_gravity_power_delete__ = 165,\n  vf_create_gravity_delete__ = 166,\n  vf_gravity_heal_delete__ = 167,\n  vf_gravity_rush_delete__ = 168,\n  vf_gravity_armor_delete__ = 169,\n  vf_gravity_recovery_delete__ = 170,\n  vf_fire_ice_train_delete__ = 171,\n  vf_wind_earth_elec_train_delete__ = 172,\n  vf_dark_holy_train_delete__ = 173,\n  vf_condition_shield_delete__ = 174,\n  vf_create_bubble_delete__ = 175,\n  vf_sharp_evade_delete__ = 176,\n  vf_bubble_heal_delete__ = 177,\n  vf_bubble_power_delete__ = 178,\n  vf_matchless_delete__ = 179,\n  vf_activate_bubble_delete__ = 180,\n  vf_energy_recovery_delete__ = 181,\n  vf_energy_morale_charge_delete__ = 182,\n  vf_shock_train_delete__ = 183,\n  vf_create_energy_delete__ = 184,\n  vf_shock_recovery_delete__ = 185,\n  vf_sharp_nerve_delete__ = 186,\n  vf_internal_injury_delete__ = 187,\n  vf_ducking_master_delete__ = 188,\n  vf_blitz_general_delete__ = 189,\n  vf_mana_train_delete__ = 190,\n  vf_ancient_will_delete__ = 191,\n  vf_ancient_essence_delete__ = 192,\n  vf_ancient_potential_delete__ = 193,\n  vf_mana_shield_delete__ = 194,\n  vf_sprint_blessing_delete__ = 195,\n  vf_elemental_curse_delete__ = 196,\n  vf_summon_master_delete__ = 197,\n  vf_prepare_power_delete__ = 198,\n  vf_mana_booster_delete__ = 199,\n  vf_fairy_harmony_delete__ = 200,\n  vf_ancient_magic_delete__ = 201,\n  vf_endurance_song_delete__ = 202,\n  vf_master_song_delete__ = 203,\n  vf_wind_song_delete__ = 204,\n  vf_guardian_serenade_delete__ = 205,\n  vf_counter_serenade_delete__ = 206,\n  vf_increment_heal_delete__ = 207,\n  vf_increment_magic_song_delete__ = 208,\n  vf_blessing_goddess_delete__ = 209,\n  vf_guardian_angel_delete__ = 210,\n  vf_active_card_delete__ = 211,\n  vf_bonus_card_delete__ = 212,\n  vf_shuffle_master_delete__ = 213,\n  vf_wariness_delete__ = 214,\n  vf_heal_card_delete__ = 215,\n  vf_wind_wing_delete__ = 216,\n  vf_ruin_master_delete__ = 217,\n  vf_stacked_master_delete__ = 218,\n  vf_card_collector_delete__ = 219,\n  vf_handgun_master_delete__ = 220,\n  vf_shotgun_master_delete__ = 221,\n  vf_rifle_master_delete__ = 222,\n  vf_gun_guard_delete__ = 223,\n  vf_agile_delete__ = 224,\n  vf_unhindered_move_delete__ = 225,\n  vf_weakness_hunt_delete__ = 226,\n  vf_lonely_hunter_delete__ = 227,\n  vf_calm_aim_delete__ = 228,\n  vf_gun_master_delete__ = 229,\n  vf_burning_time_delete__ = 230,\n  vf_firepower_charge_delete__ = 231,\n  vf_safety_fire_delete__ = 232,\n  vf_effective_firepower_delete__ = 233,\n  vf_defense_module_delete__ = 234,\n  vf_gravity_module_delete__ = 235,\n  vf_battle_heat_delete__ = 236,\n  vf_atomic_bomb_delete__ = 237,\n  vf_quick_silverhawk_delete__ = 238,\n  vf_communion_delete__ = 239,\n  vf_wind_fury_delete__ = 240,\n  vf_master_hunter_delete__ = 241,\n  vf_hawk_blow_delete__ = 242,\n  vf_energy_regen_delete__ = 243,\n  vf_inc_energy_explosion_delete__ = 244,\n  vf_energy_stable_delete__ = 245,\n  vf_energy_shield_delete__ = 246,\n  vf_energy_cycle_delete__ = 247,\n  vf_inc_energy_attack_delete__ = 248,\n  vf_fire_ice_delete__ = 249,\n  vf_energy_fury_delete__ = 250,\n  vf_energy_compress_delete__ = 251,\n  vf_strong_heart_delete__ = 252,\n  vf_last_bubble_delete__ = 253,\n  vf_critical_bubble_delete__ = 254,\n  vf_iron_bubble_delete__ = 255,\n  vf_last_energy_delete__ = 256,\n  vf_recharge_serenade_delete__ = 257,\n  vf_heal_serenade_delete__ = 258,\n  vf_aierce_attack_delete__ = 259,\n  vf_giant_hunt_delete__ = 260,\n  vf_hunter_eyes_delete__ = 261,\n  vf_giant_spear_delete__ = 262,\n  vf_limit_conquest_delete__ = 263,\n  vf_warrior_instinct_delete__ = 264,\n  vf_lance_specialist_delete__ = 265,\n  vf_quick_move_delete__ = 266,\n  vf_core_supply_delete__ = 267,\n  vf_vitality_promotion_delete__ = 268,\n  vf_enlightenment_delete__ = 269,\n  identity_lancemaster_climax = 270,\n  identity_lancemaster_selfcontrol = 271,\n  vf_death_orb_delete__ = 272,\n  vf_absorb_orb_delete__ = 273,\n  vf_quick_arts_delete__ = 274,\n  vf_protect_orb_delete__ = 275,\n  vf_orbelixir_delete__ = 276,\n  vf_chain_attack_delete__ = 277,\n  vf_burst_strike_delete__ = 278,\n  vf_arts_rush_delete__ = 279,\n  identity_demonic_repression = 280,\n  identity_demonic_impulse = 281,\n  identity_blade_burst = 282,\n  identity_blade_linger = 283,\n  vf_skill_upgrade_delete__ = 284,\n  vf_mind_control_delete__ = 285,\n  vf_time_extension_delete__ = 286,\n  vf_self_defence_delete__ = 287,\n  vf_skin_regeneration_delete__ = 288,\n  vf_fever_pitch_delete__ = 289,\n  vf_devil_power_delete__ = 290,\n  vf_revocation_delete__ = 291,\n  identity_holyknight_judge = 292,\n  identity_holyknight_bless = 293,\n  life_herbalism_super_armor = 294,\n  life_lumbering_super_armor = 295,\n  life_mining_super_armor = 296,\n  life_hunting_super_armor = 297,\n  life_fishing_super_armor = 298,\n  life_archaeology_super_armor = 299,\n  life_herbalism_add_buff = 300,\n  life_lumbering_add_buff = 301,\n  life_mining_add_buff = 302,\n  life_hunting_add_buff = 303,\n  life_fishing_add_buff = 304,\n  life_archaeology_add_buff = 305,\n  life_herbalism_skill_cooldown = 306,\n  life_lumbering_skill_cooldown = 307,\n  life_mining_skill_cooldown = 308,\n  life_hunting_skill_cooldown = 309,\n  life_fishing_skill_cooldown = 310,\n  life_archaeology_skill_cooldown = 311,\n  life_herbalism_condition_level = 312,\n  life_lumbering_condition_level = 313,\n  life_mining_condition_level = 314,\n  life_hunting_condition_level = 315,\n  life_fishing_condition_level = 316,\n  life_archaeology_condition_level = 317,\n  identity_scouter_arthetine = 318,\n  identity_scouter_legacy = 319,\n  voyage_ship_repair_charge_reduce = 320,\n  life_all_profession_condition_level = 321,\n  life_all_mastery_level = 322,\n  identity_reaper_moon = 323,\n  identity_reaper_thirst = 324,\n  headattack_master = 325,\n  identity_devil_hunter_female_enhance_stance = 326,\n  identity_devil_hunter_female_hunt_time = 327,\n  identity_battle_master_male_one_punch = 328,\n  identity_battle_master_male_rampage = 329,\n  identity_elemental_master_ignition = 330,\n  identity_elemental_master_circulation = 331,\n  maneuver_attack = 332,\n  nondirection_attack = 333,\n  dagger_critical = 334,\n  signature_move = 335,\n  adrenaline = 336,\n  rescue = 337,\n  until_over = 338,\n  gravity_glove = 339,\n  bilitzkrieg = 340,\n  near_death_experience_2 = 341,\n  identity_yinyangshi_return = 342,\n  identity_yinyangshi_fullbloom = 343,\n  identity_weather_artist_monsoon = 344,\n  identity_weather_artist_storm = 345,\n  identity_berserker_female_devourer = 346,\n  identity_berserker_female_punisher = 347,\n  identity_soul_eater_tricall = 348,\n  identity_soul_eater_scythe = 349,\n  near_death_experience_3 = 350,\n  identity_infighter_male_dusk = 351,\n  identity_infighter_male_sura = 352,\n}\nexport enum addontype {\n  none = 0,\n  slot = 1,\n  stat = 2,\n  ability_point = 3,\n  combat_effect = 4,\n  skill_damage = 5,\n  skill_critical_ratio = 6,\n  skill_critical_damage = 7,\n  skill_penetration = 8,\n  npc_grade_less_damage = 9,\n  npc_grade_less_critical_ratio = 10,\n  npc_grade_less_critical_damage = 11,\n  npc_grade_less_penetration = 12,\n  npc_grade_greater_damage = 13,\n  npc_grade_greater_critical_ratio = 14,\n  npc_grade_greater_critical_damage = 15,\n  npc_grade_greater_penetration = 16,\n  npc_species_damage = 17,\n  npc_species_critical_ratio = 18,\n  npc_species_critical_damage = 19,\n  npc_species_penetration = 20,\n  npc_attr_damage = 21,\n  npc_attr_critical_ratio = 22,\n  npc_attr_critical_damage = 23,\n  npc_attr_penetration = 24,\n  mana_reduction = 25,\n  skill_mana_reduction = 26,\n  skill_cooldown_reduction = 27,\n  ability_feature = 28,\n  class_option = 29,\n  ability_point_passive = 30,\n  instrument = 31,\n  skill_feature = 32,\n  npc_adaptation = 33,\n  skill_group_damage = 34,\n  skill_group_cooldown_reduction = 35,\n  skill_level = 36,\n  skill_feature_level = 37,\n  life_casting_speed = 38,\n  life_casting_tier = 39,\n  life_bonus_type_success = 40,\n  life_bonus_type_extra = 41,\n  life_bonus_type_skill_bonus = 42,\n  life_bonus_type_minigame_perfect = 43,\n  life_durability_bonus = 44,\n  life_mini_game_difficulty = 45,\n  combat_effect_cooldown_reduction = 46,\n  skill_damage_addend = 47,\n  awakening_usable_count_addend = 48,\n  battle_item_heal = 49,\n  party_heal = 50,\n  party_shield = 51,\n  identity_gauge = 52,\n  attack_power_amplify_addend = 53,\n  attack_power_amplify_multiplier = 54,\n  not_in_party_damage = 55,\n  skill_effect_group_set_damage = 56,\n}\nexport enum blockskilltype {\n  success = 0,\n  fail = 1,\n  inprogress = 2,\n  start = 3,\n}\nexport enum buffshowprioritycategory {\n  pet = 0,\n  classskill = 1,\n  ability = 2,\n  set = 3,\n  cook = 4,\n  identity = 5,\n  bracelet = 6,\n  battleitem = 7,\n  elixir = 8,\n  etc = 9,\n}\nexport enum contentstatustype {\n  none = 0,\n  periodquest_day = 1,\n  periodquest_week = 2,\n  chaos = 3,\n  guardian = 4,\n  challenge_guardian = 5,\n  abyss = 6,\n  challenge_abyss = 7,\n  abyss_raid = 8,\n  commander = 9,\n  rehearsal = 10,\n  dejavu = 11,\n  week_gold_info = 12,\n  not_reward_allview = 13,\n  special_commander = 14,\n  abyss_raid_gate = 15,\n  end_gold_info = 16,\n  kazeroth = 17,\n  epic_raid_gate = 18,\n}\nexport enum combateffectactiontype {\n  none = 0,\n  modify_damage = 1,\n  modify_final_damage = 2,\n  modify_critical_ratio = 3,\n  modify_critical_multiplier = 4,\n  modify_penetration = 5,\n  modify_penetration_when_critical = 6,\n  exec_active_effect_when_damage = 7,\n  exec_active_effect_when_critical = 8,\n  exec_reactive_effect_when_miss = 9,\n  exec_reactive_effect_when_damage = 10,\n  exec_reactive_effect_when_critical = 11,\n  exec_after_effect = 12,\n  exec_after_skill = 13,\n  apply_heal = 14,\n  modify_reactive_damage = 15,\n  modify_damage_shield_multiplier = 16,\n  exec_active_effect_when_kill = 17,\n  exec_start_skill = 18,\n  modify_penetration_addend = 19,\n  modify_penetration_addend_when_critical = 20,\n  modify_reactive_critical_multiplier = 21,\n  modify_damage_when_critical = 22,\n  modify_paralyzation_point = 23,\n  exec_when_counter = 24,\n  exec_when_be_killed = 25,\n}\nexport enum combateffectactortype {\n  none = 0,\n  self = 1,\n  target = 2,\n  caster = 3,\n}\nexport enum combateffectconditiontype {\n  none = 0,\n  current_skill = 1,\n  hp_less = 2,\n  hp_greater = 3,\n  mp_less = 4,\n  mp_greater = 5,\n  npc_grade_less = 6,\n  npc_grade_greater = 7,\n  npc_grade_equal = 8,\n  npc_species = 9,\n  npc_attr = 10,\n  abnormal_move = 11,\n  abnormal_status = 12,\n  abnormal_move_immune = 13,\n  abnormal_status_immune = 14,\n  abnormal_move_all = 15,\n  pc = 16,\n  skill_effect_id = 17,\n  identity_stack_count = 18,\n  status_effect_immunetype = 19,\n  abnormal_not_move = 20,\n  target_count = 21,\n  skill_identity_category = 22,\n  identity_element_value = 23,\n  directional_attack = 24,\n  current_skill_group = 25,\n  abnormal_move_status_all = 26,\n  identity_stance = 27,\n  pc_skill = 28,\n  skill_effect_group_set = 29,\n  npc_id = 30,\n  identity_gauge0_value_less = 31,\n  pc_without_me = 32,\n  npc_scaled_level_equal = 33,\n  npc_scaled_level_less = 34,\n  npc_scaled_level_greater = 35,\n  not_skill_effect_id = 36,\n  abnormal_move_not_immune = 37,\n  apply_target_marking = 38,\n  damage_attr = 39,\n  identity_element_value_less = 40,\n  command_skill_type = 41,\n}\nexport enum damageattr {\n  none = 0,\n  fire = 1,\n  ice = 2,\n  electricity = 3,\n  wind = 4,\n  earth = 5,\n  dark = 6,\n  holy = 7,\n}\nexport enum damagetype {\n  physics = 0,\n  magic = 1,\n}\nexport enum equipcategory {\n  na = 0,\n  weapon = 1,\n  armor_helmet = 2,\n  armor_top = 3,\n  armor_pants = 4,\n  armor_glove = 5,\n  armor_pauldron = 6,\n  accessory_necklace = 7,\n  accessory_earring = 8,\n  accessory_ring = 9,\n  accessory_bracelet = 10,\n  assistance_voyge = 11,\n  assistance_life = 12,\n  assistance_combat = 13,\n}\nexport enum equipslot {\n  weapon = 0,\n  head = 1,\n  upper_body = 2,\n  lower_body = 3,\n  hand = 4,\n  shoulder = 5,\n  neck = 6,\n  ear1 = 7,\n  ear2 = 8,\n  finger1 = 9,\n  finger2 = 10,\n  ability_stone = 11,\n  avatar_weapon = 12,\n  avatar_head = 13,\n  avatar_upper_body = 14,\n  avatar_lower_body = 15,\n  avatar_instrument = 16,\n  avatar_face1 = 17,\n  avatar_face2 = 18,\n  avatar_weapon_outfit = 19,\n  avatar_head_outfit = 20,\n  avatar_upper_body_outfit = 21,\n  avatar_lower_body_outfit = 22,\n  avatar_instrument_outfit = 23,\n  avatar_face1_outfit = 24,\n  avatar_face2_outfit = 25,\n  bracelet = 26,\n  assistance_voyage = 27,\n  assistance_life = 28,\n  assistance_combat = 29,\n  avatar_footstep = 30,\n  avatar_footstep_outfit = 31,\n  avatar_polymorph_skin = 32,\n}\nexport enum elixirparttype {\n  common = 0,\n  head = 1,\n  upperbody = 2,\n  lowerbody = 3,\n  hand = 4,\n  shoulder = 5,\n}\nexport enum hitflag {\n  normal = 0,\n  critical = 1,\n  miss = 2,\n  invincible = 3,\n  dot = 4,\n  immune = 5,\n  immune_silenced = 6,\n  font_silenced = 7,\n  dot_critical = 8,\n  dodge = 9,\n  reflect = 10,\n  damage_share = 11,\n  dodge_hit = 12,\n}\nexport enum hitoption {\n  back_attack = 0,\n  frontal_attack = 1,\n  flank_attack = 2,\n  reduce_damage = 3,\n  replace_font = 4,\n  replace_normalattack = 5,\n}\nexport enum identitycategory {\n  none = 0,\n  berserker_normal = 1,\n  berserker_rush = 2,\n  warlord_normal = 3,\n  warlord_shield_of_battlefield = 4,\n  destroyer_normal = 5,\n  destroyer_focus = 6,\n  destroyer_release = 7,\n  battle_master_normal = 8,\n  battle_master_bubble = 9,\n  infighter_normal = 10,\n  infighter_vigor = 11,\n  infighter_shock = 12,\n  forcemaster_normal = 13,\n  forcemaster_soul = 14,\n  lance_master_normal = 15,\n  lance_master_wild = 16,\n  lance_master_focus = 17,\n  devil_hunter_normal = 18,\n  devil_hunter_pistol = 19,\n  devil_hunter_shotgun = 20,\n  devil_hunter_rifle = 21,\n  blaster_normal = 22,\n  blaster_cannon = 23,\n  hawkeye_normal = 24,\n  hawkeye_summon = 25,\n  summoner_normal = 26,\n  summoner_ancient = 27,\n  arcana_normal = 28,\n  arcana_stack = 29,\n  arcana_ruin = 30,\n  arcana_card = 31,\n  bard_normal = 32,\n  bard_serenade = 33,\n  blade_burst = 34,\n  holyknight_normal = 35,\n  holyknight_holy = 36,\n  holyknight_retribution = 37,\n  demonic_normal = 38,\n  demonic_capture = 39,\n  demonic_demon = 40,\n  warlord_lance = 41,\n  reaper_normal = 42,\n  reaper_dagger = 43,\n  reaper_shadow = 44,\n  reaper_swoop = 45,\n  scouter_scout = 46,\n  scouter_drone = 47,\n  scouter_hyper_sync = 48,\n  scouter_fusion = 49,\n  blade_normal = 50,\n  elemental_master_normal = 51,\n  elemental_master_fire = 52,\n  elemental_master_electricity = 53,\n  elemental_master_ice = 54,\n  yinyangshi_normal = 55,\n  yinyangshi_yin = 56,\n  yinyangshi_yang = 57,\n  weather_artist_weapon = 58,\n  weather_artist_weather = 59,\n  summoner_summon = 60,\n  soul_eater_hollow = 61,\n  soul_eater_killer = 62,\n  soul_eater_death = 63,\n}\nexport enum itemcategory {\n  na = 0,\n  equip_weapon_sword = 10101,\n  equip_weapon_hammer = 10102,\n  equip_weapon_gunlance = 10103,\n  equip_weapon_bow = 10104,\n  equip_weapon_gun = 10105,\n  equip_weapon_launcher = 10106,\n  equip_weapon_triple_sword = 10107,\n  equip_weapon_no_name = 10108,\n  equip_weapon_gunblade = 10109,\n  equip_weapon_staff1 = 10110,\n  equip_weapon_staff2 = 10111,\n  equip_weapon_liana_harp = 10112,\n  equip_weapon_heavy_gauntlet = 10113,\n  equip_weapon_symbol = 10114,\n  equip_weapon_element = 10115,\n  equip_weapon_tarot_card = 10116,\n  equip_weapon_geomungo = 10117,\n  equip_weapon_ductile_gauntlet = 10118,\n  equip_weapon_sub_machine_gun = 10119,\n  equip_weapon_lance = 10120,\n  equip_weapon_dual_sword = 10121,\n  equip_weapon_demonic_weapon = 10122,\n  equip_weapon_holy_sword = 10123,\n  equip_weapon_dagger = 10124,\n  equip_weapon_gun_female = 10125,\n  equip_weapon_element_male = 10126,\n  equip_weapon_giant_staff = 10127,\n  equip_weapon_pen = 10128,\n  equip_weapon_umbrella = 10129,\n  equip_weapon_sword_female = 10130,\n  equip_weapon_scythe = 10131,\n  equip_weapon_heavy_gauntlet_male = 10132,\n  equip_armor_helmet = 10201,\n  equip_armor_top = 10202,\n  equip_armor_pants = 10203,\n  equip_armor_glove = 10204,\n  equip_armor_pauldron = 10205,\n  equip_accessory_necklace = 10401,\n  equip_accessory_earring = 10402,\n  equip_accessory_ring = 10403,\n  equip_accessory_bracelet = 10404,\n  equip_ability_stone = 10500,\n  equip_assistance_voyage = 10601,\n  equip_assistance_life = 10602,\n  equip_assistance_combat = 10603,\n  equip_etc_talisman = 10701,\n  life_tool_glove = 20101,\n  life_tool_axe = 20102,\n  life_tool_pickaxe = 20103,\n  life_tool_machete = 20104,\n  life_tool_fishingrod = 20105,\n  life_tool_shovel = 20106,\n  life_tool_marble = 20107,\n  life_tool_perfume = 20108,\n  life_tool_saw = 20109,\n  useup_potion = 30100,\n  useup_food = 30200,\n  useup_misc = 30300,\n  useup_misc_revive_coin = 30301,\n  useup_misc_messenger_medal = 30302,\n  useup_misc_pheon = 30303,\n  useup_misc_jumping_token = 30304,\n  useup_battle_item_common = 30401,\n  useup_battle_item_dungeon = 30402,\n  useup_battle_item_raid = 30403,\n  useup_battle_item_common_attack = 30411,\n  useup_battle_item_dungeon_attack = 30412,\n  useup_battle_item_common_buff = 30421,\n  useup_battle_item_dungeon_buff = 30422,\n  useup_battle_item_common_function = 30431,\n  useup_battle_item_dungeon_function = 30432,\n  useup_battle_item_raid_function = 30433,\n  useup_battle_item_common_heal = 30441,\n  useup_battle_item_dungeon_heal = 30442,\n  useup_stash_expander_pc = 30501,\n  useup_stash_expander_account = 30502,\n  useup_quest_starter = 30600,\n  useup_secret_dungeon_map = 30700,\n  useup_adv_book_collection = 30801,\n  useup_adv_book_food = 30802,\n  useup_book_social_action = 30901,\n  useup_book_pet_social_action = 30902,\n  useup_book_toy = 30903,\n  useup_random_box_locked = 31001,\n  useup_random_box_unlocked = 31002,\n  useup_random_box_unlocked_weapon = 31003,\n  useup_random_box_unlocked_armor_helmet = 31004,\n  useup_random_box_unlocked_armor_top = 31005,\n  useup_random_box_unlocked_armor_pants = 31006,\n  useup_random_box_unlocked_armor_glove = 31007,\n  useup_random_box_unlocked_armor_pauldron = 31008,\n  useup_random_box_unlocked_accessory_necklace = 31009,\n  useup_random_box_unlocked_accessory_earring = 31010,\n  useup_random_box_unlocked_accessory_ring = 31011,\n  useup_random_box_unlocked_equip = 31012,\n  useup_random_box_unlocked_armor = 31013,\n  useup_random_box_unlocked_accessory = 31014,\n  useup_random_box_unlocked_enchant_stat = 31031,\n  useup_random_box_unlocked_enchant_attr = 31032,\n  useup_random_box_unlocked_enchant_immunity = 31033,\n  useup_random_box_unlocked_enchant_species = 31034,\n  useup_random_box_unlocked_gem = 31040,\n  useup_random_box_unlocked_card = 31041,\n  useup_random_box_unlocked_ship_material = 31042,\n  useup_random_box_unlocked_avatar = 31051,\n  useup_random_box_unlocked_material_enhance = 31060,\n  useup_random_box_unlocked_vehicle = 31070,\n  useup_random_box_unlocked_pet = 31080,\n  useup_random_box_unlocked_abilitystone = 31090,\n  useup_init_skill_battle = 31101,\n  useup_init_life_na = 31201,\n  useup_init_life_herbalism = 31202,\n  useup_init_life_lumbering = 31203,\n  useup_init_life_mining = 31204,\n  useup_init_life_hunting = 31205,\n  useup_init_life_fishing = 31206,\n  useup_init_life_archaeology = 31207,\n  useup_init_life_astrology = 31208,\n  useup_init_life_speaking = 31209,\n  useup_add_skill_point_battle = 31301,\n  useup_add_skill_point_life = 31302,\n  useup_equip_preset_expander_normal = 31401,\n  useup_equip_preset_expander_premium = 31402,\n  useup_hunting_chase_key = 31501,\n  useup_hunting_chase_secret_map = 31502,\n  useup_skillbook_normal = 31601,\n  useup_archeology_parabolic_reflector = 31701,\n  useup_archeology_ancient_book = 31702,\n  useup_victory_crest_special = 31801,\n  useup_add_crew = 31900,\n  useup_add_ship = 31901,\n  useup_add_sail = 31902,\n  useup_add_voyage_luck = 31903,\n  useup_add_ship_avatar = 31904,\n  useup_add_trophy = 31905,\n  useup_add_town_mood = 31906,\n  useup_add_town_dress = 31907,\n  useup_add_town_guestbook_bg = 31908,\n  useup_card = 32000,\n  useup_card_exp = 32001,\n  useup_toy = 32100,\n  useup_character_tendency = 32200,\n  useup_honor_title = 32300,\n  useup_vehicle = 32400,\n  useup_engrave_book = 32500,\n  useup_add_permanent_attr = 32600,\n  useup_add_permanent_attr_combat_skill = 32601,\n  useup_add_permanent_attr_life_skill = 32602,\n  useup_add_permanent_attr_stat = 32603,\n  useup_add_permanent_attr_stat_con = 32604,\n  useup_add_permanent_attr_stat_criticalhit = 32605,\n  useup_add_permanent_attr_stat_endurance = 32606,\n  useup_add_permanent_attr_stat_mastery = 32607,\n  useup_add_permanent_attr_stat_oppression = 32608,\n  useup_add_permanent_attr_stat_rapidity = 32609,\n  useup_add_permanent_attr_stat_specialty = 32610,\n  useup_add_permanent_attr_tendency_char = 32611,\n  useup_add_permanent_attr_tendency_courage = 32612,\n  useup_add_permanent_attr_tendency_intellect = 32613,\n  useup_add_permanent_attr_tendency_kindness = 32614,\n  useup_secret_prop_map_normal = 32701,\n  useup_secret_prop_map_voyage = 32702,\n  useup_add_max_count = 32800,\n  useup_add_town_resource = 32900,\n  useup_add_pet = 33000,\n  useup_add_skill_rune = 33100,\n  useup_add_town_placement_prop = 33200,\n  useup_add_town_placement_npc = 33201,\n  useup_add_town_activity_point = 33300,\n  useup_add_town_crew = 33400,\n  useup_add_raid_rest_gauge = 33500,\n  useup_yoz_pot = 33600,\n  useup_extend_duration_time = 33700,\n  useup_town_chef_packed_meal = 33800,\n  useup_add_town_item_assmbly = 33900,\n  useup_life_boosting = 34000,\n  useup_exp_potion_combat = 34100,\n  useup_paid_service_bm = 34201,\n  useup_paid_service_event = 34202,\n  useup_add_money = 34300,\n  useup_add_money_trade_gold_deposit = 34301,\n  useup_add_money_jumping_trade_gold_deposit = 34302,\n  useup_emoticon = 34400,\n  useup_exp_combat_immediately = 34501,\n  useup_exp_herbalism_immediately = 34502,\n  useup_exp_lumbering_immediately = 34503,\n  useup_exp_mining_immediately = 34504,\n  useup_exp_hunting_immediately = 34505,\n  useup_exp_fishing_immediately = 34506,\n  useup_exp_archaeology_immediately = 34507,\n  useup_exp_realm_immediately = 34508,\n  useup_add_town_jukebox_music = 34600,\n  useup_add_selfie_item = 34700,\n  useup_etc_talisman = 34801,\n  useup_etc_message_npc_spawn = 34802,\n  useup_etc_honor_compensation = 34803,\n  useup_gem_reward = 34900,\n  useup_aos_equip = 35000,\n  useup_aos_useup = 35100,\n  useup_battle_token_item_common = 36001,\n  useup_battle_token_item_dungeon = 36002,\n  useup_battle_token_item_raid = 36003,\n  useup_battle_token_item_common_attack = 36011,\n  useup_battle_token_item_common_buff = 36021,\n  useup_battle_token_item_common_function = 36031,\n  useup_battle_token_item_dungeon_function = 36032,\n  useup_battle_token_item_raid_function = 36033,\n  useup_battle_token_item_common_heal = 36041,\n  useup_add_mvp_background = 37000,\n  quest_element = 40100,\n  quest_pickup = 40200,\n  quest_use = 40300,\n  quest_note = 40400,\n  quest_immediately_finish_daily = 40500,\n  install_crystal_ruby = 50101,\n  install_crystal_sappahire = 50102,\n  install_crystal_emerald = 50103,\n  install_crystal_amethyst = 50104,\n  install_crystal_topaz = 50105,\n  install_crystal_opal = 50106,\n  install_avatar_crystal_patch = 50201,\n  install_gem = 50300,\n  install_elixir = 50400,\n  general_ship_supply_normal = 60100,\n  general_ship_supply_rare = 60101,\n  general_ship_supply_elite = 60102,\n  general_lock_pick = 60200,\n  general_etc = 60300,\n  general_island_hearts = 60400,\n  general_giant_hearts = 60401,\n  general_great_pictures = 60402,\n  general_voyage_adventure = 60403,\n  general_worldtree_leaf = 60404,\n  general_adventure_medal = 60405,\n  general_orpheus_star = 60406,\n  general_memory_marble = 60407,\n  general_ticket = 60500,\n  general_token_item = 60600,\n  general_exchange = 60700,\n  general_town = 60800,\n  general_town_reduce_item_time = 60901,\n  general_town_reduce_res_time = 60902,\n  general_town_reduce_install_time = 60903,\n  general_town_reduce_research_time = 60904,\n  general_town_reduce_mission_time = 60905,\n  general_town_reduce_all_time = 60906,\n  general_add_town_activity_point = 60907,\n  general_raid_license_finish_1 = 61100,\n  general_raid_license_finish_2 = 61101,\n  general_raid_license_finish_3 = 61102,\n  general_raid_license_finish_4 = 61103,\n  general_raid_license_finish_5 = 61104,\n  general_raid_license_finish_6 = 61105,\n  general_raid_license_finish_7 = 61106,\n  general_raid_license_finish_8 = 61107,\n  general_raid_license_finish_9 = 61108,\n  general_raid_license_finish_10 = 61109,\n  general_warp_point_slot_expand = 61200,\n  general_quest_finish_daily = 61300,\n  general_secret_dungeon_map = 61400,\n  general_gacha_ticket = 61501,\n  general_gacha_mileage = 61502,\n  general_ancient_orb_unidentified = 61601,\n  general_ancient_orb = 61602,\n  general_town_token = 61700,\n  general_aos_equip = 61800,\n  general_add_max_count_daily_epona = 61900,\n  general_add_max_count_weekly_epona = 61901,\n  general_life_energy = 62000,\n  general_life_boosting = 62001,\n  general_town_jumping_ticket_bern = 62101,\n  general_town_jumping_ticket_lohendel = 62102,\n  general_town_jumping_ticket_yorn = 62103,\n  general_town_jumping_ticket_faton = 62104,\n  general_town_jumping_ticket_papunika = 62105,\n  general_town_jumping_ticket_bern_b = 62106,\n  general_town_jumping_ticket_lowen = 62107,\n  general_town_jumping_ticket_ergasia = 62108,\n  general_town_jumping_ticket_plecce = 62109,\n  general_town_jumping_ticket_voldaik = 62110,\n  general_town_jumping_ticket_kurzan_a = 62120,\n  material_etc = 70100,\n  material_life = 70200,\n  material_life_archeology = 70201,\n  material_life_fishing = 70202,\n  material_life_herbalism = 70203,\n  material_life_hunting = 70204,\n  material_life_lumbering = 70205,\n  material_life_mining = 70206,\n  material_life_etc = 70207,\n  material_assembly = 70300,\n  material_token_assembly = 70301,\n  material_awakening_skill = 70400,\n  material_tendency = 70500,\n  material_tendency_deadline = 70501,\n  material_tendency_etc = 70502,\n  material_enchant_catalyst = 70600,\n  material_enchant_scroll_stat = 70701,\n  material_enchant_scroll_attr = 70702,\n  material_enchant_scroll_species = 70703,\n  material_enchant_scroll_immunity = 70704,\n  material_enchant_scroll_any = 70705,\n  material_enchant_scroll_badge = 70706,\n  material_enchant_additive = 70800,\n  material_polish_stone = 71000,\n  material_polish_bonus_tool = 71001,\n  material_polish_core = 71002,\n  material_engrave_tool = 71100,\n  material_voyage_core = 71200,\n  material_voyage_crew = 71201,\n  material_voyage_etc = 71202,\n  material_voyage_diving = 71203,\n  material_voyage_fishing_school = 71204,\n  material_voyage_hunting = 71205,\n  material_voyage_treasure_point = 71206,\n  material_voyage_wrecked_ship = 71207,\n  material_card_etc = 71300,\n  material_arcrasium = 71400,\n  material_adv_book_food = 71500,\n  material_raid = 71600,\n  material_island = 71700,\n  material_island_token = 71701,\n  material_enhance_levelup = 71801,\n  material_enhance_additive = 71802,\n  material_sealing_tool = 71900,\n  material_magic_scroll_weapon = 72001,\n  material_magic_scroll_armor_top = 72002,\n  material_magic_scroll_armor_glove = 72003,\n  material_magic_scroll_enhance_material = 72100,\n  material_magic_scroll_craft_material = 72200,\n  material_upgrade_tool = 72300,\n  material_calibrate_tool = 72400,\n  material_option_transfer_tool = 72500,\n  material_socket_adjust_tool = 72600,\n  material_socket_amplify_tool = 72700,\n  material_option_extract_tool = 72800,\n  material_town_mana = 72900,\n  material_avatar_composite = 73000,\n  material_town_farm = 73100,\n  material_town_herbalism = 73101,\n  material_town_mining = 73102,\n  material_town_lumbering = 73103,\n  material_town_hunting = 73104,\n  material_town_fishing = 73105,\n  material_town_archeology = 73106,\n  material_life_tool = 73200,\n  material_town_life_tool = 73300,\n  material_esther_enhance = 73400,\n  material_exp_potion_pet = 73500,\n  material_grow_pet = 73501,\n  material_event = 73600,\n  material_reward = 73700,\n  material_elixir = 73800,\n  music_instrument = 80100,\n  music_note = 80200,\n  avatar_clothes_head = 90101,\n  avatar_clothes_top = 90102,\n  avatar_clothes_pants = 90103,\n  avatar_clothes_face1 = 90104,\n  avatar_clothes_face2 = 90105,\n  avatar_clothes_instrument = 90106,\n  avatar_clothes_dress = 90107,\n  avatar_clothes_head_set = 90108,\n  avatar_weapon_sword = 90201,\n  avatar_weapon_hammer = 90202,\n  avatar_weapon_gunlance = 90203,\n  avatar_weapon_bow = 90204,\n  avatar_weapon_gun = 90205,\n  avatar_weapon_launcher = 90206,\n  avatar_weapon_triple_sword = 90207,\n  avatar_weapon_no_name = 90208,\n  avatar_weapon_gunblade = 90209,\n  avatar_weapon_staff1 = 90210,\n  avatar_weapon_staff2 = 90211,\n  avatar_weapon_liana_harp = 90212,\n  avatar_weapon_heavy_gauntlet = 90213,\n  avatar_weapon_symbol = 90214,\n  avatar_weapon_element = 90215,\n  avatar_weapon_tarot_card = 90216,\n  avatar_weapon_geomungo = 90217,\n  avatar_weapon_ductile_gauntlet = 90218,\n  avatar_weapon_sub_machine_gun = 90219,\n  avatar_weapon_lance = 90220,\n  avatar_weapon_dual_sword = 90222,\n  avatar_weapon_demonic_weapon = 90223,\n  avatar_weapon_holy_sword = 90224,\n  avatar_weapon_dagger = 90225,\n  avatar_weapon_gun_female = 90226,\n  avatar_weapon_element_male = 90227,\n  avatar_weapon_giant_staff = 90228,\n  avatar_weapon_pen = 90229,\n  avatar_weapon_umbrella = 90230,\n  avatar_weapon_sword_female = 90231,\n  avatar_weapon_scythe = 90232,\n  avatar_weapon_heavy_gauntlet_male = 90233,\n  avatar_effect_footstep = 90301,\n  avatar_polymorph_skin = 90400,\n  astra_equip_will = 100101,\n  astra_equip_belief = 100102,\n  astra_equip_concentration = 100103,\n  astra_equip_desire = 100104,\n}\nexport enum itemstoragetype {\n  inven = 0,\n  equip = 1,\n  stash = 2,\n  guild = 3,\n  quest = 4,\n  mail = 5,\n  vehicle_slot = 6,\n  volatile_slot = 7,\n  life_tool_s1 = 8,\n  account_stash = 9,\n  scrap_list = 10,\n  polish_list = 11,\n  market = 12,\n  paid_item_list = 13,\n  material_stash = 14,\n  avatar_stash = 15,\n  market_temp = 16,\n  astra_equip = 17,\n  account_second_stash = 18,\n  auction = 19,\n  account_equip = 20,\n  life_tool = 21,\n  town_temp = 22,\n  survival_inven = 23,\n  gem_equip = 24,\n  town_gift = 25,\n  aos = 26,\n}\nexport enum npcgrade {\n  none = 0,\n  underling = 1,\n  normal = 2,\n  elite = 3,\n  named = 4,\n  seed = 5,\n  boss = 6,\n  raid = 7,\n  lucky = 8,\n  epic_raid = 9,\n  commander = 10,\n}\nexport enum npctype {\n  monster = 0,\n  townsfolk = 1,\n  summoned = 2,\n  totem = 3,\n  mercenary = 4,\n  pet = 5,\n  monster_pc_form = 6,\n}\nexport enum paramtype {\n  absolute = 0,\n  relative = 1,\n}\nexport enum playerclass {\n  na = 0,\n  warrior = 101,\n  berserker = 102,\n  destroyer = 103,\n  warlord = 104,\n  holyknight = 105,\n  warrior_female = 111,\n  berserker_female = 112,\n  magician = 201,\n  arcana = 202,\n  summoner = 203,\n  bard = 204,\n  elemental_master = 205,\n  fighter = 301,\n  battle_master = 302,\n  infighter = 303,\n  force_master = 304,\n  lance_master = 305,\n  fighter_male = 311,\n  battle_master_male = 312,\n  infighter_male = 313,\n  delain = 401,\n  blade = 402,\n  demonic = 403,\n  reaper = 404,\n  soul_eater = 405,\n  hunter = 501,\n  hawk_eye = 502,\n  devil_hunter = 503,\n  blaster = 504,\n  scouter = 505,\n  hunter_female = 511,\n  devil_hunter_female = 512,\n  specialist = 601,\n  yinyangshi = 602,\n  weather_artist = 603,\n  alchemist = 604,\n}\nexport enum raidresult {\n  not_yet = 0,\n  clear = 1,\n  fail_spent_all_brave_heart = 2,\n  fail_time_over = 3,\n  fail_check_ticket = 4,\n  fail_vote = 5,\n  fail_condition = 6,\n}\nexport enum raidtype {\n  none = 0,\n  normal = 1,\n  event = 2,\n  abyss = 3,\n  difficulty = 4,\n}\nexport enum skillfeaturetype {\n  none = 0,\n  enable_notify = 1,\n  enable_dir_change = 2,\n  change_move_dist = 3,\n  change_layer = 4,\n  change_stage_speed = 5,\n  change_stage_collision = 6,\n  change_max_target = 7,\n  change_area_range = 8,\n  change_area_angle = 9,\n  change_cost = 10,\n  recover_cost = 11,\n  recover_used_cost = 12,\n  reduce_default_cooldown = 13,\n  reduce_active_cooldown = 14,\n  enable_stage_buff = 15,\n  add_stage_buff = 16,\n  change_buff_area_range = 17,\n  change_buff_duration = 18,\n  change_buff_stat = 19,\n  change_buff_stack = 20,\n  change_buff_param = 21,\n  change_buff_expired_action = 22,\n  change_chain_ratio = 23,\n  change_abnormal = 24,\n  change_abnormal_ratio = 25,\n  change_dam_attr = 26,\n  change_dam_value = 27,\n  change_dam_coefficient = 28,\n  change_dam_critical = 29,\n  change_dam_critical_rate = 30,\n  change_attack_stage_speed = 31,\n  change_stack_charge_time = 32,\n  change_stack_max_count = 33,\n  change_targeting = 34,\n  change_min_range = 35,\n  change_max_range = 36,\n  change_push_info = 37,\n  change_parts_attack_attr = 38,\n  change_skill_chain_info = 39,\n  change_skill_chain_delay = 40,\n  change_behit_move_info = 41,\n  add_buff_stat = 42,\n  add_chain_skill_effect = 43,\n  remove_chain_skill_effect = 44,\n  add_chain_combat_effect = 45,\n  remove_chain_combat_effect = 46,\n  change_skill_effect_bonus = 47,\n  change_skill_effect_ai_point = 48,\n  change_dam_addend = 49,\n  change_hitted = 50,\n  change_skill_move_speed = 51,\n  add_skill_buff = 52,\n  change_skill_bonus = 53,\n  change_skill_normal_info = 54,\n  change_skill_invisibility = 55,\n  change_skill_constraint = 56,\n  change_skill_book_type = 57,\n  change_projection_skill_effect_id = 58,\n  change_push_pvp_info = 59,\n  change_forced_critical = 60,\n  change_instance_skill_effect_info = 61,\n  change_skill_start_stage = 62,\n  change_skill_effect_dir_target = 63,\n  change_stage_dir_rate = 64,\n  change_projection = 65,\n  change_skill_view = 66,\n  change_projectile_speed = 67,\n  change_projectile_dist = 68,\n  change_projectile_resourcescale = 69,\n  change_projectile_max_target_hit_count = 70,\n  change_summon_trap_lifetime = 71,\n  change_summon_trap_destroy_delaytime = 72,\n  change_summon_trap_react_info = 73,\n  change_summon_trap_invoke_effect = 74,\n  change_summon_trap_count = 75,\n  enable_identity_event = 76,\n  change_identity_proc_value = 77,\n  change_skill_effect_identity_proc_info = 78,\n  change_identity_proc_pvp_value = 79,\n  change_skill_effect_identity_proc_pvp_info = 80,\n  change_skill_effect_identity_proc_replace_info = 81,\n  change_skill_effect_identity_proc_replace_pvp_info = 82,\n  swap_chain_skill_effect = 83,\n  swap_chain_combat_effect = 84,\n  change_charge_scale = 85,\n  change_summon_npc_id = 86,\n  change_summon_npc_sight_range = 87,\n  change_summon_npc_pursuit_range = 88,\n  change_summon_npc_walk_movespeed = 89,\n  change_summon_npc_battle_movespeed = 90,\n  change_summon_npc_life_time = 91,\n  change_summon_npc_ai_index = 92,\n  change_summon_npc_invincible_duration = 93,\n  change_summon_npc_acquire_identity = 94,\n  change_summon_npc_skill_id = 95,\n  change_summon_npc_die_skill_id = 96,\n  change_summon_npc_destroy_skill_id = 97,\n  change_summon_npc_spawn_buff_id = 98,\n  change_summon_npc_count = 99,\n  change_summon_npc_stat = 100,\n  change_summon_npc_threat_point = 101,\n  change_summon_npc_skill_usable_tick = 102,\n  change_summon_npc_skill_use_order = 103,\n  change_combat_effect_arg = 104,\n  change_skill_effect_cost = 105,\n  change_accumulate_dam_rate = 106,\n  change_projectile_bank_data_addend = 107,\n  change_identity_category = 108,\n  change_skill_slot_visible_effect = 109,\n  change_attack_mask = 110,\n  change_aim_target_max_range = 111,\n}\nexport enum stattype {\n  none = 0,\n  hp = 1,\n  mp = 2,\n  str = 3,\n  agi = 4,\n  int = 5,\n  con = 6,\n  str_x = 7,\n  agi_x = 8,\n  int_x = 9,\n  con_x = 10,\n  criticalhit = 15,\n  specialty = 16,\n  oppression = 17,\n  rapidity = 18,\n  endurance = 19,\n  mastery = 20,\n  criticalhit_x = 21,\n  specialty_x = 22,\n  oppression_x = 23,\n  rapidity_x = 24,\n  endurance_x = 25,\n  mastery_x = 26,\n  max_hp = 27,\n  max_mp = 28,\n  max_hp_x = 29,\n  max_mp_x = 30,\n  max_hp_x_x = 31,\n  max_mp_x_x = 32,\n  normal_hp_recovery = 33,\n  combat_hp_recovery = 34,\n  normal_hp_recovery_rate = 35,\n  combat_hp_recovery_rate = 36,\n  normal_mp_recovery = 37,\n  combat_mp_recovery = 38,\n  normal_mp_recovery_rate = 39,\n  combat_mp_recovery_rate = 40,\n  self_recovery_rate = 41,\n  drain_hp_dam_rate = 42,\n  drain_mp_dam_rate = 43,\n  dam_reflection_rate = 44,\n  char_attack_dam = 47,\n  skill_effect_dam_addend = 48,\n  attack_power_rate = 49,\n  skill_damage_rate = 50,\n  attack_power_rate_x = 51,\n  skill_damage_rate_x = 52,\n  cooldown_reduction = 53,\n  paralyzation_point_rate = 54,\n  def = 55,\n  res = 56,\n  def_x = 57,\n  res_x = 58,\n  def_x_x = 59,\n  res_x_x = 60,\n  critical_physical_inc_rate = 65,\n  critical_magical_inc_rate = 66,\n  def_pen_rate = 67,\n  res_pen_rate = 68,\n  physical_inc_rate = 69,\n  magical_inc_rate = 70,\n  self_shield_rate = 71,\n  hit_rate = 72,\n  dodge_rate = 73,\n  critical_hit_rate = 74,\n  critical_res_rate = 75,\n  critical_dam_rate = 76,\n  attack_speed = 77,\n  attack_speed_rate = 78,\n  move_speed = 79,\n  move_speed_rate = 80,\n  prop_move_speed = 81,\n  prop_move_speed_rate = 82,\n  vehicle_move_speed = 83,\n  vehicle_move_speed_rate = 84,\n  ship_move_speed = 85,\n  ship_move_speed_rate = 86,\n  fire_dam_rate = 87,\n  ice_dam_rate = 88,\n  electricity_dam_rate = 89,\n  earth_dam_rate = 91,\n  dark_dam_rate = 92,\n  holy_dam_rate = 93,\n  elements_dam_rate = 94,\n  fire_res_rate = 95,\n  ice_res_rate = 96,\n  electricity_res_rate = 97,\n  earth_res_rate = 99,\n  dark_res_rate = 100,\n  holy_res_rate = 101,\n  elements_res_rate = 102,\n  self_cc_time_rate = 105,\n  enemy_cc_time_rate = 106,\n  identity_value1 = 107,\n  identity_value2 = 108,\n  identity_value3 = 109,\n  awakening_dam_rate = 110,\n  item_drop_rate = 111,\n  gold_rate = 112,\n  exp_rate = 113,\n  attack_power_addend = 123,\n  attack_power_addend_2 = 124,\n  npc_species_humanoid_dam_rate = 125,\n  npc_species_devil_dam_rate = 126,\n  npc_species_substance_dam_rate = 127,\n  npc_species_undead_dam_rate = 128,\n  npc_species_plant_dam_rate = 129,\n  npc_species_insect_dam_rate = 130,\n  npc_species_spirit_dam_rate = 131,\n  npc_species_wild_beast_dam_rate = 132,\n  npc_species_mechanic_dam_rate = 133,\n  npc_species_ancient_dam_rate = 134,\n  npc_species_god_dam_rate = 135,\n  npc_species_archfiend_dam_rate = 136,\n  vitality = 137,\n  ship_booter_speed = 138,\n  ship_wreck_speed_rate = 139,\n  island_speed_rate = 140,\n  attack_power_sub_rate_1 = 141,\n  attack_power_sub_rate_2 = 142,\n  physical_inc_sub_rate_1 = 143,\n  physical_inc_sub_rate_2 = 144,\n  magical_inc_sub_rate_1 = 145,\n  magical_inc_sub_rate_2 = 146,\n  skill_damage_sub_rate_1 = 147,\n  skill_damage_sub_rate_2 = 148,\n  resource_recovery_rate = 149,\n  weapon_dam = 151,\n  weapon_dam_x = 152,\n}\nexport enum statuseffecttargettooltiptype {\n  none = 0,\n  self = 1,\n  party = 2,\n  self_party = 3,\n}\nexport enum statuseffectcategory {\n  buff = 0,\n  debuff = 1,\n}\nexport enum statuseffectexpiredreasontype {\n  none = 0,\n  cancel = 1,\n  stack_count = 2,\n  lifetime = 3,\n  beattacked = 4,\n  leave_zone = 5,\n  keep_zone = 6,\n  death = 7,\n  attack_count = 8,\n  behit_count = 9,\n  unsummon = 10,\n  skill_used = 11,\n  cinematic = 12,\n  paralyzation = 13,\n  port_leave = 14,\n  revive = 15,\n  invalid_condition = 16,\n  caster_disappear = 17,\n  skill_finished = 18,\n  item_equip = 19,\n  identity = 20,\n  target_change = 21,\n  update_primary_mark = 22,\n  battle_end = 23,\n  immune_count = 24,\n}\nexport enum statuseffecttype {\n  none = 0,\n  physical_damage = 1,\n  magical_damage = 2,\n  heal = 3,\n  freeze = 4,\n  stone = 5,\n  fear = 6,\n  stun = 7,\n  sleep = 8,\n  earthquake = 9,\n  curse = 10,\n  weaken_defense = 11,\n  weaken_resistance = 12,\n  death_sentence = 13,\n  silence = 14,\n  darkness = 15,\n  vermin = 16,\n  bleeding = 17,\n  poisoning = 18,\n  electrocution = 19,\n  burn = 20,\n  move_speed_down = 21,\n  all_speed_down = 22,\n  invincibility = 23,\n  shield = 24,\n  replenish_mp = 25,\n  replenish_mp_rate = 26,\n  absorb_area = 27,\n  skill_damage_amplify = 28,\n  minion_event = 29,\n  change_hit_flag = 30,\n  identity_gauge = 31,\n  beattacked_damage_amplify = 32,\n  polymorph_pc = 33,\n  super_armor = 34,\n  invoke_skill_effect = 35,\n  forced_move = 36,\n  confinement = 37,\n  action_disable = 38,\n  herbalism_instant_durability_ignore = 39,\n  mining_add_casting_speed = 40,\n  wound = 41,\n  wild_growth = 42,\n  near_death_experience = 43,\n  change_faction = 44,\n  npc_part_invincibility = 45,\n  lumbering_sharpen = 46,\n  disguise = 47,\n  bechased_npc = 48,\n  fishing_school = 49,\n  herbalism_life_ether = 50,\n  herbalism_delicate_hands = 51,\n  ship_boost_gauge = 52,\n  hunting_chase = 53,\n  archeology_detection = 54,\n  archeology_conectration = 55,\n  archeology_sense_of_tombraider = 56,\n  reset_cooldown = 57,\n  provoke = 58,\n  ghost = 59,\n  lumbering_find_tree = 60,\n  life_casting_speed = 61,\n  life_tool_destroy_rate = 62,\n  protect = 63,\n  part_corrosion = 64,\n  voyage_supply_accelerate = 65,\n  voyage_supply_fluctuate = 66,\n  voyage_action_disable = 67,\n  voyage_boost_gauge_unobtainable = 68,\n  voyage_immune_event = 69,\n  skill_damage_amplify_attack = 70,\n  voyage_add_event_gauge = 71,\n  provoke_resist = 72,\n  ignite = 73,\n  herbalism_vitality_ether = 74,\n  herbalism_golden_finger = 75,\n  life_add_success_rate = 76,\n  ignore_immune = 77,\n  fixed_damage_self = 78,\n  voyage_boost_gauge_fluctuate = 79,\n  change_ai_point = 80,\n  aura = 81,\n  life_plus_success_rate = 82,\n  life_multiply_success_rate = 83,\n  fishing_bare_hands = 84,\n  fishing_cast_bait = 85,\n  collision_disable = 86,\n  instant_stat_amplify = 88,\n  ship_wreck = 89,\n  burn_mp = 90,\n  voyage_luck_recovery_increment = 91,\n  ai_point_amplify = 92,\n  life_multiply_exp_rate = 93,\n  pvp_token_reward_increase_percent = 94,\n  voyage_luck_drop_amplify = 95,\n  increase_identity_gauge = 96,\n  pc_stat_min_max_fix = 97,\n  reverse_ruin_drop_increase_percent = 98,\n  notice_gauge = 99,\n  back_attack_resist = 100,\n  directional_attack_amplify = 101,\n  hunting_observe = 102,\n  note_key_input = 103,\n  attack_power_amplify = 104,\n  time_stop = 105,\n  pheromone = 106,\n  life_drop_add_rate = 107,\n  life_durability_rate = 108,\n  instant_stat_amplify_by_contents = 109,\n  voyage_pause_event = 110,\n  life_exp_add_rate = 111,\n  reverse_ruin_add_exp_rate = 112,\n  linkable_invoke_effect = 113,\n  bullet_time = 114,\n  reflect_damage = 115,\n  reverse = 116,\n  detect = 117,\n  map_symbol = 118,\n  map_symbol_hide = 119,\n  force_field = 120,\n  mind_control = 121,\n  hide_target_ui = 122,\n  masking = 123,\n  mana_shield = 124,\n  detected_bush = 125,\n  paralyzation = 126,\n  confusion = 127,\n  change_material = 128,\n  linked_target_invoke = 129,\n  pattern_identity = 130,\n  beam_attack = 131,\n  fall_down = 132,\n  drown = 133,\n  infinity_hp = 134,\n  light_source = 135,\n  outline = 136,\n  fall_down_immune = 137,\n  dynamic_camera = 138,\n  bechased_pc = 139,\n  confront = 140,\n  party_drain = 141,\n  change_npc_idle = 142,\n  look_target = 143,\n  counter_attack_fx_visible = 144,\n  add_part_attack_level = 145,\n  unconditional_directional_attack = 146,\n  change_target_ui = 147,\n  contents_gauge_reduce = 148,\n  primary_enemy_mark = 149,\n  part_damage_amplify = 150,\n  notice_part_hp = 151,\n}\nexport enum triggersignaltype {\n  none = 0,\n  out = 1,\n  click_click = 2,\n  door_open = 3,\n  door_close = 4,\n  switch_on = 5,\n  switch_off = 6,\n  hit_hit = 7,\n  hit_destruct = 8,\n  grip_grip = 9,\n  volume_enter = 10,\n  volume_leave = 11,\n  volume_on = 12,\n  volume_off = 13,\n  npc_spawn = 14,\n  npc_dead = 15,\n  npc_event_1 = 16,\n  npc_event_2 = 17,\n  npc_event_3 = 18,\n  npc_event_4 = 19,\n  npc_event_5 = 20,\n  yes = 21,\n  no = 22,\n  prop_pickup = 23,\n  prop_rotate_start = 24,\n  prop_rotate_cancel = 25,\n  prop_rotate_end = 26,\n  assembled = 27,\n  user_signal = 28,\n  volume_inputkey = 29,\n  shared_click = 30,\n  shared_despawn = 31,\n  dungeon_cleared = 32,\n  coop_quest_start = 33,\n  coop_quest_complete = 34,\n  coop_quest_fail = 35,\n  user_ship_wreck = 36,\n  tower_hit = 37,\n  tower_destruct = 38,\n  vehicle_enter = 39,\n  vehicle_leave = 40,\n  instancezone_load_complete = 41,\n  random_case_1 = 42,\n  random_case_2 = 43,\n  random_case_3 = 44,\n  random_case_4 = 45,\n  random_case_5 = 46,\n  npc_pathevent = 47,\n  joint_attach = 48,\n  joint_detach = 49,\n  hit_on2 = 50,\n  hit_on3 = 51,\n  coop_quest_cancel = 52,\n  dungeon_enter = 53,\n  station_disable = 54,\n  all_dead = 55,\n  all_exit = 56,\n  dungeon_phase1_clear = 57,\n  dungeon_phase1_fail = 58,\n  dungeon_phase2_clear = 59,\n  dungeon_phase2_fail = 60,\n  dungeon_phase3_clear = 61,\n  dungeon_phase3_fail = 62,\n  dungeon_phase4_clear = 63,\n  dungeon_phase4_fail = 64,\n  user_status_effect = 65,\n  instance_timer_start = 66,\n  instance_timer_end = 67,\n  instance_timer_cancel = 68,\n  instance_timer_event_1 = 69,\n  instance_timer_event_2 = 70,\n  instance_timer_event_3 = 71,\n  instance_timer_event_4 = 72,\n  instance_timer_event_5 = 73,\n  dungeon_phase5_clear = 74,\n  dungeon_phase5_fail = 75,\n  dungeon_phase6_clear = 76,\n  dungeon_phase6_fail = 77,\n  dungeon_phase1_resume = 78,\n  dungeon_phase2_resume = 79,\n  dungeon_phase3_resume = 80,\n  dungeon_phase4_resume = 81,\n  dungeon_phase5_resume = 82,\n  dungeon_phase6_resume = 83,\n  track_move_start_1 = 84,\n  track_move_start_2 = 85,\n  track_move_start_3 = 86,\n  track_move_failure = 87,\n  hit_restore_start = 88,\n  hit_restore_finish = 89,\n  zone_level_normal = 90,\n  zone_level_hard = 91,\n  zone_level_hellchaos = 92,\n  zone_level_challenge = 93,\n  zone_level_special = 94,\n  occupation_none_to_red = 95,\n  occupation_none_to_blue = 96,\n  occupation_blue_to_red = 97,\n  occupation_red_to_blue = 98,\n  instance_timer_event_6 = 99,\n  instance_timer_event_7 = 100,\n  instance_timer_event_8 = 101,\n  instance_timer_event_9 = 102,\n  instance_timer_event_10 = 103,\n  user_status_effect_removed = 104,\n  zone_level_extreme = 105,\n}\nexport enum zonebufftarget {\n  none = 0,\n  pc = 1,\n  monster = 2,\n  npc = 3,\n  all = 4,\n}\nexport enum zonecontenttype {\n  none = 0,\n  change_class = 1,\n  dungeon_story_mission = 2,\n  dungeon_party = 3,\n  dungeon_ark = 4,\n  dungeon_default = 5,\n  ghost_ship = 6,\n  wrecked_ship = 7,\n  dungeon_death_scene = 8,\n  dungeon_labyrinth = 9,\n  dungeon_epic_raid = 10,\n  dungeon_jumping_mode = 11,\n  dungeon_troop_set = 12,\n  reverse_ruin = 13,\n  reverse_ruin_lobby = 14,\n  battlefield_open_match = 15,\n  epic_gate = 16,\n  scene_replay = 17,\n  way_of_throne = 18,\n  survival = 19,\n}\nexport enum zonelevel {\n  normal = 0,\n  hard = 1,\n  hellchaos = 2,\n  challenge = 3,\n  special = 4,\n  extreme = 5,\n}\n","import { TypedEmitter } from \"tiny-typed-emitter\";\r\nimport type { MeterData } from \"../data\";\r\nimport type { StatusEffectDataLog } from \"../packets/log/structures/StatusEffectData\";\r\nimport type { NewPC } from \"../packets/log/types\";\r\nimport { type Entity, EntityType, type Player } from \"./entityTracker\";\r\nimport type { PartyTracker } from \"./partytracker\";\r\nimport { statuseffectexpiredreasontype, statuseffecttargettooltiptype } from \"../packets/generated/enums\";\r\n\r\nexport enum StatusEffectTargetType {\r\n  Party = 0,\r\n  Local = 1,\r\n}\r\nexport enum StatusEffectCategory {\r\n  Other = 0,\r\n  Debuff = 1,\r\n}\r\n\r\nexport enum StatusEffectBuffCategory {\r\n  Other = 0,\r\n  Bracelet = 1,\r\n  Etc = 2,\r\n  Battleitem = 3,\r\n}\r\n\r\nexport enum StatusEffectShowType {\r\n  Other = 0,\r\n  All = 1,\r\n}\r\n\r\nexport enum StatusEffectType {\r\n  Shield = 0,\r\n  Other = 1,\r\n}\r\n\r\nexport interface StatusEffect {\r\n  instanceId: number;\r\n  statusEffectId: number;\r\n  targetId: TargetId;\r\n  sourceId: TargetId;\r\n  type: StatusEffectTargetType;\r\n  dbTarget: keyof typeof statuseffecttargettooltiptype;\r\n  value: number;\r\n  category: StatusEffectCategory;\r\n  buffCategory: StatusEffectBuffCategory;\r\n  showType: StatusEffectShowType;\r\n  effectType: StatusEffectType;\r\n  expirationDelay: number;\r\n  expirationTimer: NodeJS.Timer | undefined;\r\n  expireAt: Date | undefined;\r\n  occurTime: Date;\r\n  timestamp: bigint;\r\n  name: string;\r\n  pktTime: Date;\r\n  stackCount: number;\r\n}\r\n\r\ninterface StatusTrackerEvents {\r\n  shieldChanged: (se: StatusEffect, oldValue: number, newValue: number) => void;\r\n  shieldApplied: (se: StatusEffect) => void;\r\n}\r\n\r\ntype StatusEffectInstanceId = number;\r\ntype TargetId = bigint;\r\ntype StatusEffectRegistry = Map<StatusEffectInstanceId, StatusEffect>;\r\ntype PlayerStatusEffectRegistry = Map<TargetId, StatusEffectRegistry>;\r\nexport class StatusTracker extends TypedEmitter<StatusTrackerEvents> {\r\n  static TIMEOUT_DELAY_MS = 1000;\r\n\r\n  PartyStatusEffectRegistry: PlayerStatusEffectRegistry;\r\n  LocalStatusEffectRegistry: PlayerStatusEffectRegistry;\r\n\r\n  #partyTracker: PartyTracker;\r\n  #data: MeterData;\r\n\r\n  #isLive: boolean;\r\n\r\n  private debug;\r\n  private trace = false;\r\n\r\n  constructor(partyTracker: PartyTracker, data: MeterData, isLive = true, debug = Boolean(process.env[\"DEV\"])) {\r\n    super();\r\n    this.PartyStatusEffectRegistry = new Map();\r\n    this.LocalStatusEffectRegistry = new Map();\r\n    this.debug = debug;\r\n    this.#partyTracker = partyTracker;\r\n    this.#data = data;\r\n    this.#isLive = isLive;\r\n  }\r\n\r\n  private getStatusEffectRegistryForPlayer(id: TargetId, t: StatusEffectTargetType): StatusEffectRegistry {\r\n    const registry: PlayerStatusEffectRegistry = this.getPlayerRegistry(t);\r\n    const ser = registry.get(id);\r\n    if (ser) return ser;\r\n    const newEntry: StatusEffectRegistry = new Map();\r\n    registry.set(id, newEntry);\r\n    return newEntry;\r\n  }\r\n\r\n  private hasStatusEffectRegistryForPlayer(id: TargetId, t: StatusEffectTargetType): boolean {\r\n    const registry: PlayerStatusEffectRegistry = this.getPlayerRegistry(t);\r\n    return registry.has(id);\r\n  }\r\n\r\n  private getPlayerRegistry(t: StatusEffectTargetType): PlayerStatusEffectRegistry {\r\n    switch (t) {\r\n      case StatusEffectTargetType.Local:\r\n        return this.LocalStatusEffectRegistry;\r\n      case StatusEffectTargetType.Party:\r\n        return this.PartyStatusEffectRegistry;\r\n      default:\r\n        break;\r\n    }\r\n    return this.LocalStatusEffectRegistry;\r\n  }\r\n\r\n  public RemoveLocalObject(objectId: bigint, pktTime: Date) {\r\n    const registry = this.LocalStatusEffectRegistry.get(objectId);\r\n    if (registry) {\r\n      for (const [, se] of registry) {\r\n        this.RemoveStatusEffect(objectId, se.instanceId, StatusEffectTargetType.Local, undefined, pktTime);\r\n      }\r\n    }\r\n    this.LocalStatusEffectRegistry.delete(objectId);\r\n  }\r\n\r\n  public RemovePartyObject(objectId: bigint, pktTime: Date) {\r\n    const registry = this.PartyStatusEffectRegistry.get(objectId);\r\n    if (registry) {\r\n      for (const [, se] of registry) {\r\n        this.RemoveStatusEffect(objectId, se.instanceId, StatusEffectTargetType.Party, undefined, pktTime);\r\n      }\r\n    }\r\n    this.PartyStatusEffectRegistry.delete(objectId);\r\n  }\r\n\r\n  public RegisterStatusEffect(se: StatusEffect) {\r\n    const registry = this.getStatusEffectRegistryForPlayer(se.targetId, se.type);\r\n    const oldEffect = registry.get(se.instanceId);\r\n    if (oldEffect) {\r\n      if (this.#isLive && oldEffect.expirationTimer) {\r\n        clearTimeout(oldEffect.expirationTimer);\r\n        oldEffect.expirationTimer = undefined;\r\n      }\r\n    } else if (se.effectType === StatusEffectType.Shield) {\r\n      this.emit(\"shieldApplied\", se);\r\n    }\r\n    registry.set(se.instanceId, se);\r\n\r\n    this.SetupStatusEffectTimeout(se);\r\n  }\r\n\r\n  public HasAnyStatusEffect(\r\n    id: TargetId,\r\n    t: StatusEffectTargetType,\r\n    statusEffectIds: number[],\r\n    pktTime: Date\r\n  ): boolean {\r\n    if (!this.hasStatusEffectRegistryForPlayer(id, t)) return false;\r\n    const registry: StatusEffectRegistry = this.getStatusEffectRegistryForPlayer(id, t);\r\n    for (const [, se] of registry) {\r\n      if (!this.#isLive && !this.IsReplayStatusEffectValidElseRemove(se, pktTime)) continue;\r\n      for (const key of statusEffectIds) {\r\n        if (key === se.statusEffectId) return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a StatusEffect is still valid and remove it if not\r\n   * @param {StatusEffect} se The StatusEffect to check\r\n   * @param {Date} replayPktTime time of the currently processed pkt\r\n   * @returns true if the StatusEffect is still valid, false if it was cleaned up\r\n   */\r\n  private IsReplayStatusEffectValidElseRemove(se: StatusEffect, replayPktTime: Date): boolean {\r\n    if (se.expireAt === undefined || se.expireAt.getTime() > replayPktTime.getTime()) {\r\n      return true;\r\n    }\r\n    this.ExpireStatusEffectByTimeout(se);\r\n    return false;\r\n  }\r\n\r\n  public HasAnyStatusEffectFromParty(\r\n    targetId: TargetId,\r\n    et: StatusEffectTargetType,\r\n    partyId: number,\r\n    statusEffectIds: number[],\r\n    pktTime: Date\r\n  ): boolean {\r\n    if (!this.hasStatusEffectRegistryForPlayer(targetId, et)) return false;\r\n    const registry = this.getStatusEffectRegistryForPlayer(targetId, et);\r\n    for (const [, effect] of registry) {\r\n      if (!this.#isLive && !this.IsReplayStatusEffectValidElseRemove(effect, pktTime)) continue;\r\n      if (statusEffectIds.includes(effect.statusEffectId)) {\r\n        const partyIdOfSource = this.#partyTracker.getPartyIdFromEntityId(effect.sourceId);\r\n        // Dagger and Expose Weakness are for the whole raid\r\n        if (this.ValidForWholeRaid(effect)) {\r\n          // still only count if the source is in a party we know too, because then we are in the same raid\r\n          return partyIdOfSource !== undefined;\r\n        }\r\n        if (partyIdOfSource === partyId) return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public RemoveStatusEffect(\r\n    targetId: TargetId,\r\n    statusEffectId: number,\r\n    et: StatusEffectTargetType,\r\n    reason: number | undefined,\r\n    pktTime: Date\r\n  ) {\r\n    if (!this.hasStatusEffectRegistryForPlayer(targetId, et)) return;\r\n    const registry = this.getStatusEffectRegistryForPlayer(targetId, et);\r\n    const statusEffect = registry.get(statusEffectId);\r\n    if (statusEffect) {\r\n      if (this.#isLive) {\r\n        clearTimeout(statusEffect.expirationTimer);\r\n        statusEffect.expirationTimer = undefined;\r\n      }\r\n      registry.delete(statusEffectId);\r\n      if (reason === statuseffectexpiredreasontype.beattacked) {\r\n        // is live OR is still valid\r\n        if (this.#isLive || this.IsReplayStatusEffectValidElseRemove(statusEffect, pktTime))\r\n          this.RegisterValueUpdate(statusEffect, statusEffect.value, 0);\r\n      }\r\n    }\r\n    return statusEffect;\r\n  }\r\n  /**\r\n   * Gets the status effects that are on targetId. Optionally filted to only return those from a specific source.\r\n   * @param targetId Id of the object the target is on\r\n   * @param et If the statuseffect is a local target or a party target\r\n   * @param pktTime time of the pkt that triggers this check, it is used to expire statuseffects during replay mode\r\n   * @param seSourceEntityId the source entityId that the status effect needs to come from, if all sources should be allowed set to undefined\r\n   * @returns The status effects on targetId that meet the given criteria\r\n   */\r\n  public GetStatusEffects(\r\n    targetId: TargetId,\r\n    et: StatusEffectTargetType,\r\n    pktTime: Date,\r\n    seSourceEntityId: bigint | undefined\r\n  ): Array<StatusEffect> {\r\n    if (!this.hasStatusEffectRegistryForPlayer(targetId, et)) return [];\r\n    const registry = this.getStatusEffectRegistryForPlayer(targetId, et);\r\n    if (!this.#isLive) {\r\n      for (const [, effect] of registry) {\r\n        this.IsReplayStatusEffectValidElseRemove(effect, pktTime);\r\n      }\r\n    }\r\n    const allSes = [...registry.values()];\r\n    if (seSourceEntityId !== undefined) {\r\n      return allSes.filter((se, _idx, _a) => {\r\n        return se.sourceId === seSourceEntityId;\r\n      });\r\n    }\r\n    return allSes;\r\n  }\r\n\r\n  public GetStatusEffectsFromParty(\r\n    targetId: TargetId,\r\n    et: StatusEffectTargetType,\r\n    partyId: number,\r\n    pktTime: Date\r\n  ): Array<StatusEffect> {\r\n    if (!this.hasStatusEffectRegistryForPlayer(targetId, et)) return [];\r\n    const registry = this.getStatusEffectRegistryForPlayer(targetId, et);\r\n    if (!this.#isLive) {\r\n      for (const [, effect] of registry) {\r\n        this.IsReplayStatusEffectValidElseRemove(effect, pktTime);\r\n      }\r\n    }\r\n    return [...registry.values()].filter((value) => {\r\n      // Dagger and Expose Weakness are for the whole raid\r\n      if (this.ValidForWholeRaid(value)) {\r\n        // check the source is in a party we know too, because if he is he is in the same raid.\r\n        const partyIdofSource = this.#partyTracker.getPartyIdFromEntityId(value.sourceId);\r\n        return partyIdofSource !== undefined;\r\n      }\r\n      return partyId === this.#partyTracker.getPartyIdFromEntityId(value.sourceId);\r\n    });\r\n  }\r\n\r\n  public Clear(pktTime: Date) {\r\n    let seCountInLocal = 0;\r\n    for (const [, reg] of this.LocalStatusEffectRegistry) {\r\n      for (const [, se] of reg) {\r\n        this.RemoveStatusEffect(se.targetId, se.instanceId, se.type, undefined, pktTime);\r\n      }\r\n      seCountInLocal += reg.size;\r\n    }\r\n    let seCountInParty = 0;\r\n    for (const [, reg] of this.PartyStatusEffectRegistry) {\r\n      for (const [, se] of reg) {\r\n        this.RemoveStatusEffect(se.targetId, se.instanceId, se.type, undefined, pktTime);\r\n      }\r\n      seCountInParty += reg.size;\r\n    }\r\n    if (this.trace) console.log(\"On Clear SE in local\", seCountInLocal, \"in party\", seCountInParty);\r\n    this.LocalStatusEffectRegistry.clear();\r\n    this.PartyStatusEffectRegistry.clear();\r\n  }\r\n\r\n  public UpdateDuration(instanceId: number, targetId: bigint, timestamp: bigint, et: StatusEffectTargetType): void {\r\n    const registry: StatusEffectRegistry = this.getStatusEffectRegistryForPlayer(targetId, et);\r\n    const se = registry.get(instanceId);\r\n    if (se) {\r\n      const durationExtensionMs = timestamp - se.timestamp;\r\n\r\n      if (this.#isLive && se.expirationTimer) {\r\n        if (this.trace) console.log(\"Clearing timeout for\", se.instanceId, \"because of duration change\");\r\n        clearTimeout(se.expirationTimer);\r\n        se.expirationTimer = undefined;\r\n      }\r\n      if (se.expireAt) {\r\n        const timeoutTime = se.expireAt.getTime() + Number(durationExtensionMs);\r\n        const timeoutDelay = timeoutTime - se.pktTime.getTime();\r\n        if (timeoutDelay > 0) {\r\n          if (this.trace)\r\n            console.log(\r\n              \"Extending duration by\",\r\n              durationExtensionMs,\r\n              \"ms\",\r\n              \"New timeout delay\",\r\n              timeoutDelay,\r\n              \"from\",\r\n              se.expireAt.toISOString(),\r\n              \"to\",\r\n              new Date(timeoutTime).toISOString()\r\n            );\r\n          if (this.#isLive)\r\n            se.expirationTimer = setTimeout(this.ExpireStatusEffectByTimeout.bind(this, se), timeoutDelay);\r\n          se.expireAt = new Date(timeoutTime);\r\n          se.timestamp = timestamp;\r\n        } else {\r\n          se.expireAt = undefined;\r\n        }\r\n      }\r\n    } else if (this.debug) {\r\n      console.error(\r\n        \"Tried to update duration for SE with instanceId\",\r\n        instanceId,\r\n        \" on target\",\r\n        targetId,\r\n        \"but where is no such SE registered\"\r\n      );\r\n    }\r\n  }\r\n\r\n  public SyncStatusEffect(\r\n    instanceId: number,\r\n    characterId: bigint,\r\n    objectId: bigint | undefined,\r\n    value: number,\r\n    localCharacterId: bigint\r\n  ): void {\r\n    // this updates status effects for party members and other\r\n    const usePartyStatusEffects = this.#shouldUsePartyStatusEffect(characterId, localCharacterId);\r\n    const et = usePartyStatusEffects ? StatusEffectTargetType.Party : StatusEffectTargetType.Local;\r\n    const targetId = usePartyStatusEffects ? characterId : objectId;\r\n    if (!targetId) return; // we need to sync a local player but have no objectId\r\n    const registry: StatusEffectRegistry = this.getStatusEffectRegistryForPlayer(targetId, et);\r\n    const se = registry.get(instanceId);\r\n    if (!se) return;\r\n    const oldValue = se.value;\r\n    se.value = value;\r\n    this.RegisterValueUpdate(se, oldValue, value);\r\n  }\r\n\r\n  private ValidForWholeRaid(se: StatusEffect): boolean {\r\n    return (\r\n      (se.buffCategory === StatusEffectBuffCategory.Battleitem ||\r\n        se.buffCategory === StatusEffectBuffCategory.Bracelet ||\r\n        se.buffCategory === StatusEffectBuffCategory.Etc) &&\r\n      se.category === StatusEffectCategory.Debuff &&\r\n      se.showType === StatusEffectShowType.All\r\n    );\r\n  }\r\n\r\n  private SetupStatusEffectTimeout(se: StatusEffect) {\r\n    // set up the timeout to expire effect if it was not canceled by a pkt by then\r\n    // only setup expiration timer if we have a duration in the pkt, for no duration it is -1\r\n    if (se.expirationDelay > 0 && se.expirationDelay < 604800) {\r\n      // don't set timeout >= 7d\r\n      // we use the later date of start date from the pkt and then time the pkt arrived at our client\r\n      // because we don't want to expire it if we recevie a remove pkt in the future\r\n      const startDate = se.pktTime.getTime() > se.occurTime.getTime() ? se.pktTime : se.occurTime;\r\n      // se.expirationDelay is in seconds as float\r\n      const expirationDelayInMs = Math.ceil(se.expirationDelay * 1000);\r\n      const timeoutDelay =\r\n        startDate.getTime() + expirationDelayInMs + StatusTracker.TIMEOUT_DELAY_MS - se.pktTime.getTime();\r\n      se.expireAt = new Date(se.pktTime.getTime() + timeoutDelay);\r\n      if (this.trace)\r\n        console.log(\r\n          \"Setting up statuseffect expiration time for\",\r\n          se.name,\r\n          se.instanceId,\r\n          \"to\",\r\n          se.expireAt.toISOString(),\r\n          \"with delay\",\r\n          timeoutDelay\r\n        );\r\n      if (this.#isLive) se.expirationTimer = setTimeout(this.ExpireStatusEffectByTimeout.bind(this, se), timeoutDelay);\r\n    }\r\n  }\r\n\r\n  private ExpireStatusEffectByTimeout(se: StatusEffect) {\r\n    if (this.debug) console.error(\"Triggered timeout on\", se.name, \"with iid\", se.instanceId);\r\n    this.RemoveStatusEffect(se.targetId, se.instanceId, se.type, undefined, new Date());\r\n  }\r\n\r\n  private RegisterValueUpdate(se: StatusEffect, oldValue: number, newValue: number) {\r\n    if (se.effectType === StatusEffectType.Shield) {\r\n      this.emit(\"shieldChanged\", se, oldValue, newValue);\r\n    }\r\n  }\r\n\r\n  newPC(parsed: NewPC, localCharacterId: bigint, pktTime: Date) {\r\n    const shouldUsePartyStatusEffects = this.#shouldUsePartyStatusEffect(parsed.pcStruct.characterId, localCharacterId);\r\n    if (shouldUsePartyStatusEffects) {\r\n      this.RemovePartyObject(parsed.pcStruct.characterId, pktTime);\r\n    } else {\r\n      this.RemoveLocalObject(parsed.pcStruct.playerId, pktTime);\r\n    }\r\n    for (const se of parsed.pcStruct.statusEffectDatas) {\r\n      this.RegisterStatusEffect(\r\n        this.buildStatusEffect(\r\n          se,\r\n          shouldUsePartyStatusEffects ? parsed.pcStruct.characterId : parsed.pcStruct.playerId,\r\n          se.sourceId,\r\n          shouldUsePartyStatusEffects ? StatusEffectTargetType.Party : StatusEffectTargetType.Local,\r\n          pktTime\r\n        )\r\n      );\r\n    }\r\n  }\r\n  #shouldUsePartyStatusEffectForEntity(entity: Entity, localCharacterId: bigint) {\r\n    if (entity.entityType !== EntityType.Player) return false;\r\n    const player: Player = entity as Player;\r\n    return this.#shouldUsePartyStatusEffect(player.characterId, localCharacterId);\r\n  }\r\n  #shouldUsePartyStatusEffect(characterId: bigint, localCharacterId: bigint) {\r\n    const localPlayerIsInParty = this.#partyTracker.isCharacterInParty(localCharacterId);\r\n    const affectedPlayerIsInParty = this.#partyTracker.isCharacterInParty(characterId);\r\n    if (localPlayerIsInParty) {\r\n      if (!affectedPlayerIsInParty || characterId === localCharacterId) {\r\n        // not in party or local player use local status effects\r\n        return false;\r\n      }\r\n      const localPlayerPartyId = this.#partyTracker.getPartyIdFromCharacterId(localCharacterId);\r\n      const affectedPlayerPartyId = this.#partyTracker.getPartyIdFromCharacterId(characterId);\r\n      if (localPlayerPartyId === affectedPlayerPartyId) {\r\n        // same party with local player use party status effects\r\n        return true;\r\n      }\r\n      // in a party but not with the local player use local status effects\r\n      return false;\r\n    }\r\n    // local player not in a party always use local status effects\r\n    return false;\r\n  }\r\n  buildStatusEffect(\r\n    se: StatusEffectDataLog,\r\n    targetId: bigint,\r\n    sourceId: bigint,\r\n    targetType: StatusEffectTargetType,\r\n    pktTime: Date\r\n  ): StatusEffect {\r\n    const newValCandidate1: number = se.value ? se.value.readUInt32LE() : 0;\r\n    const newValCandidate2: number = se.value ? se.value.readUInt32LE(8) : 0;\r\n    const newVal = newValCandidate1 < newValCandidate2 ? newValCandidate1 : newValCandidate2;\r\n    let statusEffectCategory = StatusEffectCategory.Other;\r\n    let statusEffectBuffCategory = StatusEffectBuffCategory.Other;\r\n    let showType = StatusEffectShowType.Other;\r\n    let seName = \"Unknown\";\r\n    let statusEffectType = StatusEffectType.Other;\r\n    const effectInfo = this.#data.skillBuff.get(se.statusEffectId);\r\n    if (effectInfo) {\r\n      seName = effectInfo.name;\r\n      switch (effectInfo.category) {\r\n        case \"debuff\":\r\n          statusEffectCategory = StatusEffectCategory.Debuff;\r\n          break;\r\n      }\r\n      switch (effectInfo.buffcategory) {\r\n        case \"bracelet\":\r\n          statusEffectBuffCategory = StatusEffectBuffCategory.Bracelet;\r\n          break;\r\n        case \"etc\":\r\n          statusEffectBuffCategory = StatusEffectBuffCategory.Etc;\r\n          break;\r\n        case \"battleitem\":\r\n          statusEffectBuffCategory = StatusEffectBuffCategory.Battleitem;\r\n          break;\r\n      }\r\n      switch (effectInfo.iconshowtype) {\r\n        case \"all\":\r\n          showType = StatusEffectShowType.All;\r\n          break;\r\n      }\r\n      switch (effectInfo.type) {\r\n        case \"shield\":\r\n          statusEffectType = StatusEffectType.Shield;\r\n          break;\r\n      }\r\n    }\r\n    return {\r\n      instanceId: se.effectInstanceId,\r\n      sourceId: sourceId,\r\n      statusEffectId: se.statusEffectId,\r\n      targetId: targetId,\r\n      type: targetType,\r\n      dbTarget: effectInfo?.target ?? \"none\",\r\n      value: newVal,\r\n      buffCategory: statusEffectBuffCategory,\r\n      category: statusEffectCategory,\r\n      showType: showType,\r\n      expirationDelay: se.totalTime,\r\n      expirationTimer: undefined,\r\n      timestamp: se.endTick,\r\n      expireAt: undefined,\r\n      occurTime: se.occurTime,\r\n      name: seName,\r\n      pktTime: pktTime,\r\n      effectType: statusEffectType,\r\n      stackCount: se.stackCount,\r\n    };\r\n  }\r\n  getStatusEffects(\r\n    sourceEntity: Entity,\r\n    targetEntity: Entity | undefined,\r\n    localCharacterId: bigint,\r\n    pktTime: Date\r\n  ): [[number, bigint, number][], [number, bigint, number][]] {\r\n    const statusEffectsOnTarget: [number, bigint, number][] = [];\r\n    const statusEffectsOnSource: [number, bigint, number][] = [];\r\n\r\n    const shouldUsePartyBuffForSource = this.#shouldUsePartyStatusEffectForEntity(sourceEntity, localCharacterId);\r\n    const sourceEffects = this.GetStatusEffects(\r\n      shouldUsePartyBuffForSource ? (sourceEntity as Player).characterId : sourceEntity.entityId,\r\n      shouldUsePartyBuffForSource ? StatusEffectTargetType.Party : StatusEffectTargetType.Local,\r\n      pktTime,\r\n      undefined\r\n    );\r\n    for (const se of sourceEffects) statusEffectsOnSource.push([se.statusEffectId, se.sourceId, se.stackCount]);\r\n\r\n    if (targetEntity) {\r\n      const shouldUsePartyBuffForTarget = this.#shouldUsePartyStatusEffectForEntity(targetEntity, localCharacterId);\r\n      const sourceIsInParty = this.#partyTracker.isEntityInParty(sourceEntity.entityId);\r\n      const sourcePartyId = sourceIsInParty\r\n        ? this.#partyTracker.getPartyIdFromEntityId(sourceEntity.entityId)\r\n        : undefined;\r\n      const targetEffects =\r\n        sourceIsInParty && sourcePartyId\r\n          ? this.GetStatusEffectsFromParty(\r\n              shouldUsePartyBuffForTarget ? (targetEntity as Player).characterId : targetEntity.entityId,\r\n              shouldUsePartyBuffForTarget ? StatusEffectTargetType.Party : StatusEffectTargetType.Local,\r\n              sourcePartyId,\r\n              pktTime\r\n            )\r\n          : this.GetStatusEffects(\r\n              shouldUsePartyBuffForTarget ? (targetEntity as Player).characterId : targetEntity.entityId,\r\n              shouldUsePartyBuffForTarget ? StatusEffectTargetType.Party : StatusEffectTargetType.Local,\r\n              pktTime,\r\n              sourceEntity.entityId\r\n            );\r\n      for (const se of targetEffects) {\r\n        //Filter out debuffs that are on target but that should only apply to caster\r\n        if (\r\n          se.type === StatusEffectTargetType.Local &&\r\n          se.category === StatusEffectCategory.Debuff &&\r\n          se.sourceId !== sourceEntity.entityId &&\r\n          se.dbTarget === \"self\"\r\n        )\r\n          continue;\r\n        statusEffectsOnTarget.push([se.statusEffectId, se.sourceId, se.stackCount]);\r\n      }\r\n    }\r\n    return [statusEffectsOnSource, statusEffectsOnTarget];\r\n  }\r\n}\r\n","import type { ItemSetCount, ItemSetData, MeterData, PassiveOption, SkillFeatureOption } from \"../data\";\nimport { TripodIndex } from \"../packets/common/TripodIndex\";\nimport { TripodLevel } from \"../packets/common/TripodLevel\";\nimport { equipcategory, npcgrade, playerclass, stattype } from \"../packets/generated/enums\";\nimport { EquipItemDataLog } from \"../packets/log/structures/EquipItemData\";\nimport type { InitEnv, InitPC, NewNpc, NewNpcSummon, NewPC } from \"../packets/log/types\";\nimport type { LogEvent } from \"./logEvent\";\nimport type { PartyTracker } from \"./partytracker\";\nimport type { PCIdMapper } from \"./pcidmapper\";\nimport { StatusEffectTargetType, StatusTracker } from \"./statustracker\";\n\nexport class EntityTracker {\n  #pcIdMapper: PCIdMapper;\n  #partyTracker: PartyTracker;\n  #statusTracker: StatusTracker;\n  #data: MeterData;\n\n  entities = new Map<bigint, Entity>();\n  localPlayer: Player;\n\n  constructor(pcIdMapper: PCIdMapper, partyTracker: PartyTracker, statusTracker: StatusTracker, data: MeterData) {\n    this.#pcIdMapper = pcIdMapper;\n    this.#partyTracker = partyTracker;\n    this.#statusTracker = statusTracker;\n    this.#data = data;\n\n    this.localPlayer = {\n      entityId: 0n,\n      entityType: EntityType.Player,\n      name: \"You\",\n      class: 0,\n      gearLevel: 0,\n      characterId: 0n,\n      stance: 0,\n      stats: new Map(),\n      skills: new Map(),\n      items: {},\n    };\n  }\n  processNewPC(pkt: LogEvent<NewPC>): Player | undefined {\n    const parsed = pkt.parsed;\n    if (!parsed) return;\n    const player: Player = {\n      entityId: parsed.pcStruct.playerId,\n      entityType: EntityType.Player,\n      name: parsed.pcStruct.name,\n      class: parsed.pcStruct.classId,\n      gearLevel: parsed.pcStruct.maxItemLevel,\n      characterId: parsed.pcStruct.characterId,\n      stance: 0,\n      stats: this.#data.getStatPairMap(parsed.pcStruct.statPair),\n      skills: new Map(),\n      items: {},\n    };\n    this.entities.set(player.entityId, player);\n    const oldEntityId = this.#pcIdMapper.getEntityId(player.characterId);\n    if (oldEntityId) {\n      this.#partyTracker.changeEntityId(oldEntityId, parsed.pcStruct.playerId);\n    }\n    this.#pcIdMapper.addMapping(player.characterId, player.entityId);\n    this.#partyTracker.completeEntry(player.characterId, player.entityId);\n\n    this.#statusTracker.newPC(parsed, this.localPlayer.characterId, pkt.time);\n\n    //Items\n    player.itemSet = this.getPlayerSetOptions(parsed.pcStruct.equipItemDataList);\n\n    const equipList: PlayerItemData[] = [];\n    parsed.pcStruct.equipItemDataList.forEach((item) => {\n      if (item.id !== undefined && item.slot !== undefined) equipList.push({ id: item.id, slot: item.slot });\n    });\n    player.items.equipList = equipList;\n\n    const lifeToolList: PlayerItemData[] = [];\n    parsed.pcStruct.equipLifeToolDataList.forEach((item) => {\n      if (item.id !== undefined && item.slot !== undefined) lifeToolList.push({ id: item.id, slot: item.slot });\n    });\n    player.items.lifeToolList = lifeToolList;\n    return player;\n  }\n  processInitEnv(pkt: LogEvent<InitEnv>) {\n    const parsed = pkt.parsed;\n    if (!parsed) return;\n\n    if (this.localPlayer.entityId !== 0n) this.#partyTracker.changeEntityId(this.localPlayer.entityId, parsed.playerId);\n\n    this.entities.clear(); //TODO: here we clear entities, this might be uncompatible with keeping previous encounter visible\n\n    //Restore localplayer\n    const player: Player = {\n      entityId: parsed.playerId,\n      entityType: EntityType.Player,\n      name: this.localPlayer.name,\n      class: this.localPlayer.class,\n      gearLevel: this.localPlayer.gearLevel,\n      characterId: this.localPlayer.characterId,\n      stance: this.localPlayer.stance,\n      stats: this.localPlayer.stats,\n      skills: this.localPlayer.skills,\n      items: this.localPlayer.items,\n    };\n    this.localPlayer = player;\n    this.entities.set(player.entityId, player);\n    this.#pcIdMapper.clear();\n    this.#statusTracker.Clear(pkt.time);\n    if (player.characterId !== 0n) this.#pcIdMapper.addMapping(player.characterId, player.entityId);\n    if (this.localPlayer && this.localPlayer.characterId && this.localPlayer.characterId > 0n)\n      this.#partyTracker.completeEntry(this.localPlayer.characterId, parsed.playerId);\n  }\n  processInitPC(pkt: LogEvent<InitPC>): Player | undefined {\n    const parsed = pkt.parsed;\n    if (!parsed) return;\n\n    this.entities.clear(); //TODO: here we clear entities, this might be uncompatible with keeping previous encounter visible\n\n    const player: Player = {\n      entityId: parsed.playerId,\n      entityType: EntityType.Player,\n      name: parsed.name,\n      class: parsed.classId,\n      gearLevel: parsed.gearLevel,\n      characterId: parsed.characterId,\n      stance: 0,\n      stats: this.#data.getStatPairMap(parsed.statPair),\n      skills: new Map(),\n      items: parsed.characterId === this.localPlayer.characterId ? this.localPlayer.items : {},\n    };\n    this.localPlayer = player;\n    this.entities.set(player.entityId, player);\n    this.#pcIdMapper.addMapping(player.characterId, player.entityId);\n    this.#partyTracker.setOwnName(parsed.name);\n    this.#partyTracker.completeEntry(player.characterId, parsed.playerId);\n    this.#statusTracker.RemoveLocalObject(parsed.playerId, pkt.time);\n    for (const se of parsed.statusEffectDatas) {\n      const sourceEntity = this.getSourceEntity(se.sourceId);\n      this.#statusTracker.RegisterStatusEffect(\n        this.#statusTracker.buildStatusEffect(\n          se,\n          parsed.playerId,\n          sourceEntity.entityId,\n          StatusEffectTargetType.Local,\n          pkt.time\n        )\n      );\n    }\n    return player;\n  }\n  processNewNpc(pkt: LogEvent<NewNpc>): Npc | undefined {\n    const parsed = pkt.parsed;\n    if (!parsed) return;\n\n    let isBoss = false;\n    const npcData = this.#data.npc.get(parsed.npcStruct.typeId);\n    if (\n      npcData &&\n      [npcgrade.boss, npcgrade.raid, npcgrade.epic_raid, npcgrade.commander].includes(npcgrade[npcData.grade])\n    ) {\n      isBoss = true;\n    }\n    const npc: Npc = {\n      entityId: parsed.npcStruct.objectId,\n      entityType: EntityType.Npc,\n      name: npcData?.name ?? parsed.npcStruct.objectId.toString(16),\n      typeId: parsed.npcStruct.typeId,\n      isBoss,\n      grade: npcData?.grade ?? \"none\",\n      pushimmune: npcData?.pushimmune ?? false,\n      stats: this.#data.getStatPairMap(parsed.npcStruct.statPair),\n      level: parsed.npcStruct.level,\n      balanceLevel: parsed.npcStruct.balanceLevel ?? parsed.npcStruct.level,\n    };\n    const esther = this.#data.getNpcEsther(parsed.npcStruct.typeId);\n    if (esther !== undefined) {\n      npc.entityType = EntityType.Esther;\n      npc.name = esther.name;\n      (npc as Esther).icon = esther.icon;\n    }\n    this.entities.set(npc.entityId, npc);\n    this.#statusTracker.RemoveLocalObject(parsed.npcStruct.objectId, pkt.time);\n    for (const se of parsed.npcStruct.statusEffectDatas) {\n      const sourceEntity = this.getSourceEntity(se.sourceId);\n      this.#statusTracker.RegisterStatusEffect(\n        this.#statusTracker.buildStatusEffect(\n          se,\n          parsed.npcStruct.objectId,\n          sourceEntity.entityId,\n          StatusEffectTargetType.Local,\n          pkt.time\n        )\n      );\n    }\n    return npc;\n  }\n  processNewNpcSummon(pkt: LogEvent<NewNpcSummon>): Summon | undefined {\n    const parsed = pkt.parsed;\n    if (!parsed) return;\n\n    let isBoss = false;\n    const npc = this.#data.npc.get(parsed.npcData.typeId);\n    if (npc && [\"boss\", \"raid\", \"epic_raid\", \"commander\"].includes(npc.grade)) {\n      isBoss = true;\n    }\n    const summon: Summon = {\n      entityId: parsed.npcData.objectId,\n      entityType: EntityType.Summon,\n      name: npc?.name ?? parsed.npcData.objectId.toString(16),\n      ownerId: parsed.ownerId,\n      typeId: parsed.npcData.typeId,\n      isBoss,\n      grade: npc?.grade ?? \"none\",\n      pushimmune: npc?.pushimmune ?? false,\n      stats: this.#data.getStatPairMap(parsed.npcData.statPair),\n      level: parsed.npcData.level,\n      balanceLevel: parsed.npcData.balanceLevel ?? parsed.npcData.level,\n    };\n    this.#statusTracker.RemoveLocalObject(parsed.npcData.objectId, pkt.time);\n    for (const se of parsed.npcData.statusEffectDatas) {\n      const sourceEntity = this.getSourceEntity(se.sourceId);\n      this.#statusTracker.RegisterStatusEffect(\n        this.#statusTracker.buildStatusEffect(\n          se,\n          parsed.npcData.objectId,\n          sourceEntity.entityId,\n          StatusEffectTargetType.Local,\n          pkt.time\n        )\n      );\n    }\n    this.entities.set(summon.entityId, summon);\n    return summon;\n  }\n  getPlayerSetOptions(itemDataList: { id?: number; slot?: number }[]): PassiveOption[] {\n    const playerSet: Map<string /*name*/, Map<number /*level*/, number /*count*/>> = new Map();\n    itemDataList.forEach((item) => {\n      if (item.id && item.slot && item.slot >= equipcategory.weapon && item.slot <= equipcategory.armor_pauldron) {\n        const itemSet = this.#data.itemSet.items.get(item.id);\n        if (itemSet) {\n          let setEntry = playerSet.get(itemSet.setname);\n          if (!setEntry) {\n            setEntry = new Map();\n            playerSet.set(itemSet.setname, setEntry);\n          }\n          setEntry.set(itemSet.level, (setEntry.get(itemSet.level) ?? 0) + 1);\n        }\n      }\n    });\n    const effectiveOptions: PassiveOption[] = [];\n    playerSet.forEach((v, setName) => {\n      const effect = this.#data.itemSet.seteffects.get(setName);\n      if (!effect) return;\n      let maxCountApplied = 0;\n      let higherLevelCount = 0;\n      for (const [level, count] of [...v.entries()].sort((a, b) => b[0] - a[0])) {\n        const effectLevel = effect.get(level);\n        if (!effectLevel) return;\n        for (const [requiredLevel, options] of [...effectLevel.entries()]) {\n          if (requiredLevel > maxCountApplied && count + higherLevelCount >= requiredLevel) {\n            effectiveOptions.push(...options.options);\n            maxCountApplied = Math.max(maxCountApplied, requiredLevel);\n          }\n        }\n        higherLevelCount = count;\n      }\n    });\n    return effectiveOptions;\n  }\n  getSourceEntity(id: bigint): Entity {\n    let entity = this.entities.get(id);\n    if (entity?.entityType === EntityType.Projectile) {\n      id = (entity as Projectile).ownerId;\n    } else if (entity?.entityType === EntityType.Summon) {\n      id = (entity as Summon).ownerId;\n    }\n    entity = this.entities.get(id);\n    if (entity) return entity;\n    const newEntity = {\n      entityId: id,\n      entityType: EntityType.Npc,\n      name: id.toString(16),\n      stats: new Map(),\n    };\n    this.entities.set(id, newEntity);\n    return newEntity;\n  }\n  guessIsPlayer(entity: Entity, skillid: number): Entity {\n    const classId = this.#data.getSkillClassId(skillid);\n    if (classId !== 0) {\n      let newEntity: Player;\n      if (entity.entityType === EntityType.Player) {\n        const player = entity as Player;\n        if (player.class === classId) return player;\n        newEntity = {\n          entityId: player.entityId,\n          entityType: EntityType.Player,\n          name: player.name,\n          class: classId,\n          gearLevel: player.gearLevel,\n          characterId: player.characterId,\n          stance: player.stance,\n          stats: player.stats,\n          skills: new Map(),\n          items: {},\n        };\n      } else if (entity.entityType === EntityType.Unknown) {\n        newEntity = {\n          entityId: entity.entityId,\n          entityType: EntityType.Player,\n          name: entity.name,\n          class: classId,\n          gearLevel: 0,\n          characterId: 0n,\n          stance: 0,\n          stats: new Map(),\n          skills: new Map(),\n          items: {},\n        };\n      } else return entity;\n\n      this.entities.set(entity.entityId, newEntity);\n      return newEntity;\n    }\n    return entity;\n  }\n  getOrCreateEntity(entityId: bigint): Entity {\n    let ent = this.entities.get(entityId);\n    if (!ent) {\n      ent = { entityId, entityType: EntityType.Unknown, name: entityId.toString(16), stats: new Map() };\n      this.entities.set(entityId, ent);\n    }\n    return ent;\n  }\n  getEntityByName(name: string) {\n    return [...this.entities.values()].find((e) => e.name === name);\n  }\n}\n\nexport const enum EntityType {\n  Unknown,\n  Player,\n  Npc,\n  Summon,\n  Esther,\n  Projectile,\n}\n\nexport type Entity = {\n  entityId: bigint;\n  entityType: EntityType;\n  name: string;\n  stats: Map<stattype, bigint>;\n};\nexport type PlayerSet = Map<ItemSetData, { count: number; level: number; effects: ItemSetCount }>;\n\nexport type Player = Entity & {\n  entityType: EntityType.Player;\n  class: playerclass;\n  gearLevel: number;\n  characterId: bigint;\n  stance: number;\n  skills: Map<number /* skillid */, PlayerSkillData>;\n  itemSet?: PassiveOption[]; // TODO: store PassiveOption instead, and reprocess all items on change ?\n  items: {\n    lifeToolList?: PlayerItemData[];\n    equipList?: PlayerItemData[];\n  };\n};\nexport type PlayerItemData = {\n  id: number;\n  slot: number;\n};\n\nexport type Npc = Entity & {\n  entityType: EntityType.Npc | EntityType.Summon | EntityType.Esther;\n  typeId: number;\n  isBoss: boolean;\n  grade: keyof typeof npcgrade;\n  pushimmune: boolean;\n  level: number;\n  balanceLevel: number;\n};\n\nexport type Esther = Npc & {\n  entityType: EntityType.Esther;\n  icon: string;\n};\n\nexport type Summon = Npc & {\n  entityType: EntityType.Summon;\n  ownerId: bigint;\n};\n\nexport type Projectile = Entity & {\n  entityType: EntityType.Projectile;\n  ownerId: bigint;\n  skillEffectId: number;\n  skillId: number;\n};\n\nexport type PlayerSkillData = {\n  effects: Set<number>;\n  tripods: Map<number /* tripodindex */, TripodData>;\n  level?: number;\n  gems?: unknown;\n  rune?: unknown;\n  //skillData with db info ?\n};\nexport type TripodData = { level: number; options: SkillFeatureOption[] };\n","import { uncompressSync as lz4UncompressSync } from \"lz4-napi\";\nimport oodle from \"oodle\";\nimport { uncompress as snappyUncompress } from \"snappyjs\";\n\nexport class Decompressor {\n  oodle: oodle.Oodle;\n  xorTable: Buffer;\n\n  constructor(oodle_state: Buffer, xorTable: Buffer) {\n    this.oodle = new oodle.Oodle(oodle_state);\n    if (xorTable.length != 256) throw new Error(\"Invalid xorTable length\");\n    this.xorTable = xorTable;\n  }\n\n  decrypt(data: Buffer, xorShift: number, compression: number, xor: boolean) {\n    if (xor) this.xor(data, xorShift);\n    let out: Buffer;\n    switch (compression) {\n      case 0: {\n        // no compression\n        out = data;\n        break;\n      }\n      case 1: {\n        // lz4\n        out = lz4UncompressSync(data);\n        break;\n      }\n      case 2: {\n        // snappy\n        out = snappyUncompress(data);\n        break;\n      }\n      case 3: {\n        // oodle\n        if (data.length < 4)\n          throw new Error(`Invalid oodle packet: size=${data.length}, comp=${compression}, opcode=${xorShift}`);\n        out = this.oodle.decode(data.subarray(4), data.readUInt32LE(0));\n        break;\n      }\n      default:\n        throw new Error(`Unknown compression: ${compression}`);\n    }\n    if (out.length < 16) throw new Error(`Invalid packet: size=${out.length}, comp=${compression}, opcode=${xorShift}`);\n    return out.subarray(16);\n  }\n\n  xor(data: Buffer, seed: number) {\n    for (let i = 0; i < data.length; i++) data[i] ^= this.xorTable[seed++ % 256]!;\n  }\n}\n","import { TypedEmitter } from \"tiny-typed-emitter\";\nimport type { Decompressor } from \"../decompressor\";\nimport { mapping as pktMapping } from \"../packets/generated/mapping\";\nimport type { LogStreamEvent } from \"../packets/log/LogStreamEvent\";\nimport { codeMapping } from \"../packets/log/codeMapping\";\nimport { logMapping } from \"../packets/log/logMapping\";\nimport { PKT, PKTStream } from \"../pkt-stream\";\nimport {\n  HEADER_DATE_OFFSET,\n  HEADER_DATE_SIZE,\n  HEADER_FULL_SIZE,\n  HEADER_ID_OFFSET,\n  HEADER_ID_SIZE,\n  HEADER_VERSION_SIZE,\n  LogEvent,\n} from \"./logEvent\";\nimport { WriteStream, createWriteStream } from \"fs\";\nimport type { GameState } from \"./data\";\nimport { PacketBuffer } from \"../pkt-buffer\";\nimport { createReadStream } from \"fs\";\nimport { version } from \"../packets/log/version\";\n\nexport abstract class Logger extends TypedEmitter<LogStreamEvent> {\n  //Only common behaviour is the emitted logStreamEvent\n}\nexport class LiveLogger extends Logger {\n  #decompressor: Decompressor;\n  #logWriter?: WriteStream;\n  writeLogFile = false;\n  constructor(stream: PKTStream, decompressor: Decompressor, filepath?: string) {\n    super();\n    this.#decompressor = decompressor;\n    if (filepath) {\n      this.#logWriter = createWriteStream(filepath, { highWaterMark: 0 });\n    }\n\n    //Write log header\n    const versionBuffer = Buffer.allocUnsafe(HEADER_VERSION_SIZE);\n    versionBuffer.writeUIntLE(version, 0, HEADER_VERSION_SIZE);\n    this.#logWriter?.write(versionBuffer);\n\n    stream.on(\"*\", this.handlePkt.bind(this));\n  }\n  handlePkt(data: Buffer, opcode: number, compression: number, xor: boolean) {\n    try {\n      const pktMap = pktMapping.get(opcode);\n      const codeMap = codeMapping.get(opcode);\n      if (pktMap && codeMap) {\n        const [logId] = codeMap;\n        const [pktName, readPkt] = pktMap;\n        const logMap = logMapping.get(logId);\n        if (logMap) {\n          const [logName, readLog, writeLog] = logMap;\n          const pkt = new PKT(Buffer.from(data), opcode, compression, Boolean(xor), this.#decompressor, readPkt);\n          const parsed = pkt.parsed;\n          if (!parsed) return;\n          const logEvent = new LogEvent(parsed, logId, writeLog);\n          // Dispatch LogEvent\n          this.emit(logName as keyof LogStreamEvent, logEvent);\n          this.emit(\"*\", logName, logEvent);\n          // Dispatch serialized event\n          if (this.writeLogFile || logId === 9) this.appendLog(logEvent);\n        }\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  appendLog(logEvent: LogEvent<any>) {\n    if (this.#logWriter && logEvent.serialized) this.#logWriter.write(logEvent.serialized);\n  }\n}\nexport class ReplayLogger extends Logger {\n  readLogByChunk(filepath: string) {\n    const pktBuffer = new PacketBuffer();\n    const logReader = createReadStream(filepath);\n    let end = false;\n    let ver: number | undefined;\n    logReader\n      .on(\"data\", (chunk: Buffer) => {\n        if (ver === undefined) {\n          ver = this.readVersion(chunk);\n          if (ver > version) {\n            logReader.destroy();\n            return;\n          }\n          chunk = chunk.subarray(HEADER_VERSION_SIZE);\n        }\n        pktBuffer.write(chunk);\n        let pkt: Buffer | undefined;\n        while ((pkt = pktBuffer.read())) {\n          this.readLogChunk(pkt, ver);\n        }\n      })\n      .on(\"end\", () => {\n        end = true;\n        this.emit(\"fileEnd\", \"end\");\n      })\n      .on(\"close\", () => {\n        if (!end) this.emit(\"fileEnd\", \"closed\");\n      });\n  }\n  readLogChunk(buf: Buffer, version: number): false | void {\n    try {\n      if (buf.length < 8) return false;\n\n      //const len = buf.readUint16LE(HEADER_LEN_OFFSET);\n      const logId = buf.readUIntLE(HEADER_ID_OFFSET, HEADER_ID_SIZE);\n      const time = new Date(buf.readUintLE(HEADER_DATE_OFFSET, HEADER_DATE_SIZE));\n      const data = buf.subarray(HEADER_FULL_SIZE);\n\n      const logMap = logMapping.get(logId);\n      if (logMap) {\n        const [logName, readLog, writeLog] = logMap;\n        const logEvent = new LogEvent(data, logId, new Date(time), (reader) => readLog(reader, version), writeLog);\n        // Dispatch LogEvent\n        this.emit(logName as keyof LogStreamEvent, logEvent);\n        this.emit(\"*\", logName, logEvent);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  readVersion(b: Buffer): number {\n    return b.readUintLE(0, HEADER_VERSION_SIZE);\n  }\n}\n\nexport type LogFileEntry = {\n  filename: string;\n  parsedContents: GameState;\n  date: Date;\n};\n","export class Read {\n  /** Buffer */\n  b: Buffer;\n  /** Offset */\n  o: number;\n\n  constructor(buf: Buffer) {\n    this.b = buf;\n    this.o = 0;\n  }\n\n  skip(length = 0) {\n    this.o += length;\n  }\n\n  bool() {\n    return this.u8() === 1;\n  }\n\n  u8() {\n    return this.b.readUint8(this.o++);\n  }\n\n  i8() {\n    return this.b.readInt8(this.o++);\n  }\n\n  u16() {\n    const value = this.b.readUint16LE(this.o);\n    this.o += 2;\n    return value;\n  }\n\n  i16() {\n    const value = this.b.readInt16LE(this.o);\n    this.o += 2;\n    return value;\n  }\n\n  u32() {\n    const value = this.b.readUint32LE(this.o);\n    this.o += 4;\n    return value;\n  }\n\n  i32() {\n    const value = this.b.readInt32LE(this.o);\n    this.o += 4;\n    return value;\n  }\n\n  f32() {\n    const value = this.b.readFloatLE(this.o);\n    this.o += 4;\n    return value;\n  }\n\n  u64() {\n    const value = this.b.readBigUint64LE(this.o);\n    this.o += 8;\n    return value;\n  }\n\n  i64() {\n    const value = this.b.readBigInt64LE(this.o);\n    this.o += 8;\n    return value;\n  }\n\n  string(maxLength: number) {\n    let length = this.u16();\n    if (length <= maxLength) {\n      length = length * 2;\n      const value = this.b.toString(\"utf16le\", this.o, this.o + length);\n      this.o += length;\n      return value;\n    }\n    return \"\";\n  }\n\n  bytes(length = 0, maxLength?: number, multiplier?: number) {\n    if (maxLength && length > maxLength) return Buffer.alloc(0);\n    if (multiplier) length = length * multiplier;\n    const value = Buffer.from(this.b.subarray(this.o, this.o + length));\n    this.o += length;\n    return value;\n  }\n\n  array(length: number, callbackfn: (...args: any[]) => any, maxLength?: number) {\n    if (maxLength && length > maxLength) return [];\n    return new Array(length).fill(undefined).map(callbackfn);\n  }\n}\n\nexport class Write {\n  /** Buffer */\n  b: Buffer;\n  /** Offset */\n  o: number;\n\n  constructor(max = 0xffff) {\n    this.b = Buffer.allocUnsafe(max);\n    this.o = 0;\n  }\n\n  get value() {\n    return this.b.subarray(0, this.o);\n  }\n\n  skip(length = 0) {\n    this.o += length;\n  }\n\n  bool(value: boolean = false) {\n    this.u8(value ? 1 : 0);\n    return value; //Used for cleaner writers\n  }\n\n  u8(value = 0) {\n    this.b.writeUInt8(value, this.o++);\n  }\n\n  i8(value = 0) {\n    this.b.writeInt8(value, this.o++);\n  }\n\n  u16(value = 0) {\n    this.o = this.b.writeUInt16LE(value, this.o);\n  }\n\n  i16(value = 0) {\n    this.o = this.b.writeInt16LE(value, this.o);\n  }\n\n  u32(value = 0) {\n    this.o = this.b.writeUInt32LE(value, this.o);\n  }\n\n  i32(value = 0) {\n    this.o = this.b.writeInt32LE(value, this.o);\n  }\n\n  f32(value = 0) {\n    this.o = this.b.writeFloatLE(value, this.o);\n  }\n\n  u64(value = 0n) {\n    this.o = this.b.writeBigUInt64LE(BigInt(value), this.o);\n  }\n\n  i64(value = 0n) {\n    this.o = this.b.writeBigInt64LE(BigInt(value), this.o);\n  }\n\n  string(value = \"\", maxLength = 0) {\n    this.u16(value.length);\n    if (value.length <= maxLength) this.o += this.b.write(value, this.o, \"utf16le\");\n  }\n\n  /**\n   * @param opts.length Used when Buffer should be fixed length -> no header\n   * @param opts.maxLen Used when Buffer has a max number of chunk -> chunk count is written as header\n   * @param opts.lenType Required if maxLen, Used to specify header size possible values: [\"u8\", \"u16\", \"u32\"]\n   * @param opts.multiplier Default: 1, Used to specify chunk size, Buffer size should be a multiple of multiplier, defaults to 1\n   * @param opts If empty, fallback to opts.length = Buffer.length\n   */\n  bytes(\n    value = Buffer.alloc(0),\n    opts: {\n      length?: number;\n      maxLen?: number;\n      lenType?: \"u8\" | \"u16\" | \"u32\";\n      multiplier?: number;\n    } = {}\n  ) {\n    if (opts.maxLen) {\n      const chunkSize = opts.multiplier ?? 1;\n      if (value.length % chunkSize)\n        throw new Error(\n          `Error writing bytes, chunkSize should be a multiple of intut value size, got ${value.length}%${chunkSize}`\n        );\n      const count = value.length / chunkSize;\n      if (count > opts.maxLen)\n        throw new Error(`Error writing bytes, input value size exceeded maxLen, got ${count} > ${opts.maxLen}`);\n      if (!opts.lenType)\n        throw new Error(`Error writing bytes, invalid lenType when writing chunks, got ${opts.lenType}`);\n\n      this[opts.lenType](count);\n    } else if (opts.length && value.length !== opts.length) {\n      throw new Error(\n        `Error writing bytes, input value size doesn't match opts.length, ${value.length} !== ${opts.lenType}`\n      );\n    }\n    this.o += value.copy(this.b, this.o);\n\n    // TODO: minLength value for fixed length?\n    // TODO: check if this is working\n    /* if (lenType) this[lenType](value.length);\n      if (maxLength && value.length > maxLength) return;\n      if (maxLength && value.length < maxLength) value = Buffer.concat([value, Buffer.alloc(maxLength - value.length)]);\n      this.offset += value.copy(this.buf, this.offset); */\n  }\n\n  /**\n   *\n   * @param opts.maxLen Max size of array, size is set to 0 if overflow\n   * @param opts.lenTypeUsed to specify header size possible values: [\"u8\", \"u16\", \"u32\"]\n   */\n  array(\n    value: any[] = [],\n    opts: { maxLen: number; lenType: \"u8\" | \"u16\" | \"u32\" },\n    callbackfn: (...args: any[]) => any\n  ) {\n    if (value === undefined || value.length > opts.maxLen) {\n      this[opts.lenType](0);\n      return;\n    }\n    this[opts.lenType](value.length);\n    value.forEach(callbackfn);\n  }\n}\n","// Auto Generated, do not edit.\nimport type { Read } from \"../../stream\";\nexport type AbilityData = {\n  id: number;\n  level: number;\n  points: number;\n};\nexport function read(reader: Read) {\n  const data = {} as AbilityData;\n  data.id = reader.u32();\n  data.points = reader.u16();\n  data.level = reader.u8();\n  return data;\n}\n","// Auto Generated, do not edit.\nimport { Read } from \"../../stream\";\nimport * as AbilityData from \"../structures/AbilityData\";\nexport type PKTAbilityChangeNotify = {\n  abilityDataList: AbilityData.AbilityData[];\n};\nexport function read(buf: Buffer) {\n  const reader = new Read(buf);\n  const data = {} as PKTAbilityChangeNotify;\n  data.abilityDataList = reader.array(reader.u16(), () => AbilityData.read(reader), 100);\n  return data;\n}\nexport const name = \"PKTAbilityChangeNotify\";\nexport const opcode = 0;","names":["import_fs","addontype","combateffectactiontype","combateffectactortype","combateffectconditiontype","identitycategory","npcgrade","paramtype","skillfeaturetype","stattype","zonelevel","name","skillId","oodle_state","xorTable","oodle","lz4UncompressSync","snappyUncompress","import_tiny_typed_emitter","read","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","version","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","read","version","write","read","read","name","opcode","read","read","read","read","read","read","read","read","read","read","read","read","read","name","opcode","read","read","name","opcode","read","name","opcode","read","read","version","write","read","version","write","read","read","name","opcode","read","name","opcode","read","read","read","name","opcode","read","version","write","read","version","write","read","read","name","opcode","read","read","name","opcode","read","name","opcode","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","read","name","opcode","read","name","opcode","read","name","opcode","read","version","write","read","read","read","name","opcode","read","name","opcode","read","name","opcode","read","version","write","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","opcode","name","opcode","read","version","write","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","read","version","write","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","write","name","read","version","write","name","read","version","write","name","read","version","write","name","name","read","write","import_tiny_typed_emitter","decompressor","opcode","name","read","logId","read","write","import_fs","size","import_fs","stream","decompressor","opcode","logId","logEvent","version","import_tiny_typed_emitter","import_stream","import_stream","cap","cap","cap","import_tiny_typed_emitter","import_tiny_typed_emitter","axios","logEvent","name","statusEffect","skillId","val","val2","option","name","options","write","import_path","name","path","opcode"]}