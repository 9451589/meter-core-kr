{"version":3,"sources":["../../src/logger/logger.ts","../../src/packets/stream.ts","../../src/packets/generated/structures/AbilityData.ts","../../src/packets/generated/definitions/PKTAbilityChangeNotify.ts","../../src/packets/generated/structures/ActiveAbility.ts","../../src/packets/generated/definitions/PKTActiveAbilityNotify.ts","../../src/packets/generated/definitions/PKTAddonSkillFeatureChangeNotify.ts","../../src/packets/generated/definitions/PKTAuthTokenResult.ts","../../src/packets/generated/definitions/PKTBlockSkillStateNotify.ts","../../src/packets/generated/definitions/PKTCounterAttackNotify.ts","../../src/packets/generated/definitions/PKTDeathNotify.ts","../../src/packets/common/LostArkDateTime.ts","../../src/packets/generated/structures/EquipItemData.ts","../../src/packets/generated/definitions/PKTEquipChangeNotify.ts","../../src/packets/generated/definitions/PKTEquipLifeToolChangeNotify.ts","../../src/packets/generated/definitions/PKTIdentityStanceChangeNotify.ts","../../src/packets/generated/definitions/PKTInitAbility.ts","../../src/packets/generated/definitions/PKTInitEnv.ts","../../src/packets/generated/structures/StatusEffectData.ts","../../src/packets/common/ReadNBytesInt64.ts","../../src/packets/generated/structures/PeriodUpdateStatData.ts","../../src/packets/generated/definitions/PKTInitPC.ts","../../src/packets/generated/structures/Struct_147.ts","../../src/packets/generated/structures/Struct_674.ts","../../src/packets/generated/structures/Struct_681.ts","../../src/packets/generated/structures/Struct_626.ts","../../src/packets/generated/structures/Struct_768.ts","../../src/packets/generated/structures/Struct_809.ts","../../src/packets/generated/structures/Struct_680.ts","../../src/packets/generated/structures/BossKillData.ts","../../src/packets/generated/structures/Struct_624.ts","../../src/packets/generated/structures/Struct_673.ts","../../src/packets/generated/structures/Struct_577.ts","../../src/packets/generated/structures/ItemData.ts","../../src/packets/generated/definitions/PKTInitItem.ts","../../src/packets/generated/structures/CooldownData.ts","../../src/packets/generated/definitions/PKTInitLocal.ts","../../src/packets/generated/definitions/PKTMigrationExecute.ts","../../src/packets/generated/structures/Struct_752.ts","../../src/packets/common/Angle.ts","../../src/packets/common/Vector3F.ts","../../src/packets/generated/structures/NpcData.ts","../../src/packets/generated/definitions/PKTNewNpc.ts","../../src/packets/generated/definitions/PKTNewNpcSummon.ts","../../src/packets/generated/structures/PCStruct.ts","../../src/packets/generated/structures/TrackMoveInfo.ts","../../src/packets/generated/definitions/PKTNewPC.ts","../../src/packets/common/TripodLevel.ts","../../src/packets/common/TripodIndex.ts","../../src/packets/generated/structures/ProjectileInfo.ts","../../src/packets/generated/definitions/PKTNewProjectile.ts","../../src/packets/generated/structures/TrapData.ts","../../src/packets/generated/definitions/PKTNewTrap.ts","../../src/packets/generated/definitions/PKTParalyzationStateNotify.ts","../../src/packets/generated/structures/PartyMemberData.ts","../../src/packets/generated/definitions/PKTPartyInfo.ts","../../src/packets/generated/definitions/PKTPartyLeaveResult.ts","../../src/packets/generated/definitions/PKTPartyPassiveStatusEffectAddNotify.ts","../../src/packets/generated/definitions/PKTPartyPassiveStatusEffectRemoveNotify.ts","../../src/packets/generated/definitions/PKTPartyStatusEffectAddNotify.ts","../../src/packets/generated/definitions/PKTPartyStatusEffectRemoveNotify.ts","../../src/packets/generated/definitions/PKTPartyStatusEffectResultNotify.ts","../../src/packets/generated/definitions/PKTPassiveStatusEffectAddNotify.ts","../../src/packets/generated/definitions/PKTPassiveStatusEffectRemoveNotify.ts","../../src/packets/generated/definitions/PKTRaidBegin.ts","../../src/packets/generated/definitions/PKTRaidBossKillNotify.ts","../../src/packets/generated/definitions/PKTRaidResult.ts","../../src/packets/generated/structures/UnpublishObject.ts","../../src/packets/generated/definitions/PKTRemoveObject.ts","../../src/packets/generated/definitions/PKTSkillCancelNotify.ts","../../src/packets/generated/definitions/PKTSkillCastNotify.ts","../../src/packets/common/SkillMoveOptionData.ts","../../src/packets/generated/structures/SkillDamageEvent.ts","../../src/packets/generated/structures/SkillDamageAbnormalMoveEvent.ts","../../src/packets/generated/definitions/PKTSkillDamageAbnormalMoveNotify.ts","../../src/packets/generated/definitions/PKTSkillDamageNotify.ts","../../src/packets/generated/definitions/PKTSkillStageNotify.ts","../../src/packets/common/SkillOptionData.ts","../../src/packets/generated/definitions/PKTSkillStartNotify.ts","../../src/packets/generated/definitions/PKTStatChangeOriginNotify.ts","../../src/packets/generated/definitions/PKTStatusEffectAddNotify.ts","../../src/packets/generated/definitions/PKTStatusEffectRemoveNotify.ts","../../src/packets/generated/definitions/PKTStatusEffectDurationNotify.ts","../../src/packets/generated/definitions/PKTStatusEffectSyncDataNotify.ts","../../src/packets/generated/definitions/PKTTriggerBossBattleStatus.ts","../../src/packets/generated/definitions/PKTTriggerFinishNotify.ts","../../src/packets/generated/definitions/PKTTriggerStartNotify.ts","../../src/packets/generated/definitions/PKTTroopMemberUpdateMinNotify.ts","../../src/packets/generated/definitions/PKTIdentityGaugeChangeNotify.ts","../../src/packets/generated/definitions/PKTZoneMemberLoadStatusNotify.ts","../../src/packets/generated/definitions/PKTZoneObjectUnpublishNotify.ts","../../src/packets/generated/structures/ZoneStatusEffectData.ts","../../src/packets/generated/definitions/PKTZoneStatusEffectAddNotify.ts","../../src/packets/generated/definitions/PKTZoneStatusEffectRemoveNotify.ts","../../src/packets/generated/definitions/PKTInstanceZoneEnteredNotify.ts","../../src/packets/generated/definitions/PKTSkillCooldownNotify.ts","../../src/packets/generated/definitions/PKTPCInspectResult.ts","../../src/packets/generated/mapping.ts","../../src/packets/log/codeMapping.ts","../../src/packets/log/structures/AbilityData.ts","../../src/packets/log/definitions/AbilityChangeNotify.ts","../../src/packets/log/structures/ActiveAbility.ts","../../src/packets/log/definitions/ActiveAbilityNotify.ts","../../src/packets/log/definitions/AddonSkillFeatureChangeNotify.ts","../../src/packets/log/definitions/BlockSkillStateNotify.ts","../../src/packets/log/definitions/CounterAttackNotify.ts","../../src/packets/log/definitions/DeathNotify.ts","../../src/packets/log/definitions/InitAbility.ts","../../src/packets/log/definitions/InitEnv.ts","../../src/packets/log/structures/StatusEffectData.ts","../../src/packets/log/definitions/InitPC.ts","../../src/packets/log/definitions/InitLocal.ts","../../src/packets/log/definitions/MigrationExecute.ts","../../src/packets/log/structures/NpcData.ts","../../src/packets/log/definitions/NewNpc.ts","../../src/packets/log/definitions/NewNpcSummon.ts","../../src/packets/log/structures/EquipItemData.ts","../../src/packets/log/structures/PCStruct.ts","../../src/packets/log/definitions/NewPC.ts","../../src/packets/log/structures/ProjectileInfo.ts","../../src/packets/log/definitions/NewProjectile.ts","../../src/packets/log/definitions/ParalyzationStateNotify.ts","../../src/packets/log/structures/PartyMemberData.ts","../../src/packets/log/definitions/PartyInfo.ts","../../src/packets/log/definitions/PartyLeaveResult.ts","../../src/packets/log/definitions/PartyPassiveStatusEffectAddNotify.ts","../../src/packets/log/definitions/PartyPassiveStatusEffectRemoveNotify.ts","../../src/packets/log/definitions/PartyStatusEffectAddNotify.ts","../../src/packets/log/definitions/PartyStatusEffectRemoveNotify.ts","../../src/packets/log/definitions/PartyStatusEffectResultNotify.ts","../../src/packets/log/definitions/PassiveStatusEffectAddNotify.ts","../../src/packets/log/definitions/PassiveStatusEffectRemoveNotify.ts","../../src/packets/log/definitions/RaidBossKillNotify.ts","../../src/packets/log/definitions/RaidResult.ts","../../src/packets/log/structures/UnpublishObject.ts","../../src/packets/log/definitions/RemoveObject.ts","../../src/packets/log/structures/SkillDamageEvent.ts","../../src/packets/log/structures/SkillDamageAbnormalMoveEvent.ts","../../src/packets/log/definitions/SkillDamageAbnormalMoveNotify.ts","../../src/packets/log/definitions/SkillDamageNotify.ts","../../src/packets/log/definitions/SkillStageNotify.ts","../../src/packets/log/definitions/SkillStartNotify.ts","../../src/packets/log/definitions/StatusEffectAddNotify.ts","../../src/packets/log/definitions/StatusEffectRemoveNotify.ts","../../src/packets/log/definitions/StatusEffectDurationNotify.ts","../../src/packets/log/definitions/StatusEffectSyncDataNotify.ts","../../src/packets/log/definitions/TriggerBossBattleStatus.ts","../../src/packets/log/definitions/TriggerFinishNotify.ts","../../src/packets/log/definitions/TriggerStartNotify.ts","../../src/packets/log/definitions/TroopMemberUpdateMinNotify.ts","../../src/packets/log/definitions/IdentityGaugeChangeNotify.ts","../../src/packets/log/definitions/ZoneObjectUnpublishNotify.ts","../../src/packets/log/structures/ZoneStatusEffectData.ts","../../src/packets/log/definitions/ZoneStatusEffectAddNotify.ts","../../src/packets/log/definitions/ZoneStatusEffectRemoveNotify.ts","../../src/packets/log/definitions/SkillCastNotify.ts","../../src/packets/log/definitions/IdentityStanceChangeNotify.ts","../../src/packets/log/definitions/EquipChangeNotify.ts","../../src/packets/log/definitions/EquipLifeToolChangeNotify.ts","../../src/packets/log/structures/ItemData.ts","../../src/packets/log/definitions/InitItem.ts","../../src/packets/log/structures/BossKillData.ts","../../src/packets/log/definitions/RaidBegin.ts","../../src/packets/log/definitions/ZoneMemberLoadStatusNotify.ts","../../src/packets/log/structures/TrapData.ts","../../src/packets/log/definitions/NewTrap.ts","../../src/packets/log/definitions/SkillCancelNotify.ts","../../src/packets/log/definitions/InstanceZoneEnteredNotify.ts","../../src/packets/log/definitions/SkillCooldownNotify.ts","../../src/packets/log/definitions/PCInspectResult.ts","../../src/packets/log/app/APP_StatApi.ts","../../src/packets/log/logMapping.ts","../../src/pkt-stream.ts","../../src/logger/logEvent.ts","../../src/pkt-buffer.ts","../../src/packets/log/version.ts"],"sourcesContent":["import { TypedEmitter } from \"tiny-typed-emitter\";\nimport type { Decompressor } from \"../decompressor\";\nimport { mapping as pktMapping } from \"../packets/generated/mapping\";\nimport type { LogStreamEvent } from \"../packets/log/LogStreamEvent\";\nimport { codeMapping } from \"../packets/log/codeMapping\";\nimport { logMapping } from \"../packets/log/logMapping\";\nimport { PKT, PKTStream } from \"../pkt-stream\";\nimport {\n  HEADER_DATE_OFFSET,\n  HEADER_DATE_SIZE,\n  HEADER_FULL_SIZE,\n  HEADER_ID_OFFSET,\n  HEADER_ID_SIZE,\n  HEADER_VERSION_SIZE,\n  LogEvent,\n} from \"./logEvent\";\nimport { WriteStream, createWriteStream } from \"fs\";\nimport type { GameState } from \"./data\";\nimport { PacketBuffer } from \"../pkt-buffer\";\nimport { createReadStream } from \"fs\";\nimport { version } from \"../packets/log/version\";\n\nexport abstract class Logger extends TypedEmitter<LogStreamEvent> {\n  //Only common behaviour is the emitted logStreamEvent\n}\nexport class LiveLogger extends Logger {\n  #decompressor: Decompressor;\n  #logWriter?: WriteStream;\n  writeLogFile = false;\n  constructor(stream: PKTStream, decompressor: Decompressor, filepath?: string) {\n    super();\n    this.#decompressor = decompressor;\n    if (filepath) {\n      this.#logWriter = createWriteStream(filepath, { highWaterMark: 0 });\n    }\n\n    //Write log header\n    const versionBuffer = Buffer.allocUnsafe(HEADER_VERSION_SIZE);\n    versionBuffer.writeUIntLE(version, 0, HEADER_VERSION_SIZE);\n    this.#logWriter?.write(versionBuffer);\n\n    stream.on(\"*\", this.handlePkt.bind(this));\n  }\n  handlePkt(data: Buffer, opcode: number, compression: number, xor: boolean) {\n    try {\n      const pktMap = pktMapping.get(opcode);\n      const codeMap = codeMapping.get(opcode);\n      if (pktMap && codeMap) {\n        const [logId] = codeMap;\n        const [pktName, readPkt] = pktMap;\n        const logMap = logMapping.get(logId);\n        if (logMap) {\n          const [logName, readLog, writeLog] = logMap;\n          const pkt = new PKT(Buffer.from(data), opcode, compression, Boolean(xor), this.#decompressor, readPkt);\n          const parsed = pkt.parsed;\n          if (!parsed) return;\n          const logEvent = new LogEvent(parsed, logId, writeLog);\n          // Dispatch LogEvent\n          this.emit(logName as keyof LogStreamEvent, logEvent);\n          this.emit(\"*\", logName, logEvent);\n          // Dispatch serialized event\n          if (this.writeLogFile || logId === 9) this.appendLog(logEvent);\n        }\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  appendLog(logEvent: LogEvent<any>) {\n    if (this.#logWriter && logEvent.serialized) this.#logWriter.write(logEvent.serialized);\n  }\n}\nexport class ReplayLogger extends Logger {\n  readLogByChunk(filepath: string) {\n    const pktBuffer = new PacketBuffer();\n    const logReader = createReadStream(filepath);\n    let end = false;\n    let ver: number | undefined;\n    logReader\n      .on(\"data\", (chunk: Buffer) => {\n        if (ver === undefined) {\n          ver = this.readVersion(chunk);\n          if (ver > version) {\n            logReader.destroy();\n            return;\n          }\n          chunk = chunk.subarray(HEADER_VERSION_SIZE);\n        }\n        pktBuffer.write(chunk);\n        let pkt: Buffer | undefined;\n        while ((pkt = pktBuffer.read())) {\n          this.readLogChunk(pkt, ver);\n        }\n      })\n      .on(\"end\", () => {\n        end = true;\n        this.emit(\"fileEnd\", \"end\");\n      })\n      .on(\"close\", () => {\n        if (!end) this.emit(\"fileEnd\", \"closed\");\n      });\n  }\n  readLogChunk(buf: Buffer, version: number): false | void {\n    try {\n      if (buf.length < 8) return false;\n\n      //const len = buf.readUint16LE(HEADER_LEN_OFFSET);\n      const logId = buf.readUIntLE(HEADER_ID_OFFSET, HEADER_ID_SIZE);\n      const time = new Date(buf.readUintLE(HEADER_DATE_OFFSET, HEADER_DATE_SIZE));\n      const data = buf.subarray(HEADER_FULL_SIZE);\n\n      const logMap = logMapping.get(logId);\n      if (logMap) {\n        const [logName, readLog, writeLog] = logMap;\n        const logEvent = new LogEvent(data, logId, new Date(time), (reader) => readLog(reader, version), writeLog);\n        // Dispatch LogEvent\n        this.emit(logName as keyof LogStreamEvent, logEvent);\n        this.emit(\"*\", logName, logEvent);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  readVersion(b: Buffer): number {\n    return b.readUintLE(0, HEADER_VERSION_SIZE);\n  }\n}\n\nexport type LogFileEntry = {\n  filename: string;\n  parsedContents: GameState;\n  date: Date;\n};\n","export class Read {\n  /** Buffer */\n  b: Buffer;\n  /** Offset */\n  o: number;\n\n  constructor(buf: Buffer) {\n    this.b = buf;\n    this.o = 0;\n  }\n\n  skip(length = 0) {\n    this.o += length;\n  }\n\n  bool() {\n    return this.u8() === 1;\n  }\n\n  u8() {\n    return this.b.readUint8(this.o++);\n  }\n\n  i8() {\n    return this.b.readInt8(this.o++);\n  }\n\n  u16() {\n    const value = this.b.readUint16LE(this.o);\n    this.o += 2;\n    return value;\n  }\n\n  i16() {\n    const value = this.b.readInt16LE(this.o);\n    this.o += 2;\n    return value;\n  }\n\n  u32() {\n    const value = this.b.readUint32LE(this.o);\n    this.o += 4;\n    return value;\n  }\n\n  i32() {\n    const value = this.b.readInt32LE(this.o);\n    this.o += 4;\n    return value;\n  }\n\n  f32() {\n    const value = this.b.readFloatLE(this.o);\n    this.o += 4;\n    return value;\n  }\n\n  u64() {\n    const value = this.b.readBigUint64LE(this.o);\n    this.o += 8;\n    return value;\n  }\n\n  i64() {\n    const value = this.b.readBigInt64LE(this.o);\n    this.o += 8;\n    return value;\n  }\n\n  string(maxLength: number) {\n    let length = this.u16();\n    if (length <= maxLength) {\n      length = length * 2;\n      const value = this.b.toString(\"utf16le\", this.o, this.o + length);\n      this.o += length;\n      return value;\n    }\n    return \"\";\n  }\n\n  bytes(length = 0, maxLength?: number, multiplier?: number) {\n    if (maxLength && length > maxLength) return Buffer.alloc(0);\n    if (multiplier) length = length * multiplier;\n    const value = Buffer.from(this.b.subarray(this.o, this.o + length));\n    this.o += length;\n    return value;\n  }\n\n  array(length: number, callbackfn: (...args: any[]) => any, maxLength?: number) {\n    if (maxLength && length > maxLength) return [];\n    return new Array(length).fill(undefined).map(callbackfn);\n  }\n}\n\nexport class Write {\n  /** Buffer */\n  b: Buffer;\n  /** Offset */\n  o: number;\n\n  constructor(max = 0xffff) {\n    this.b = Buffer.allocUnsafe(max);\n    this.o = 0;\n  }\n\n  get value() {\n    return this.b.subarray(0, this.o);\n  }\n\n  skip(length = 0) {\n    this.o += length;\n  }\n\n  bool(value: boolean = false) {\n    this.u8(value ? 1 : 0);\n    return value; //Used for cleaner writers\n  }\n\n  u8(value = 0) {\n    this.b.writeUInt8(value, this.o++);\n  }\n\n  i8(value = 0) {\n    this.b.writeInt8(value, this.o++);\n  }\n\n  u16(value = 0) {\n    this.o = this.b.writeUInt16LE(value, this.o);\n  }\n\n  i16(value = 0) {\n    this.o = this.b.writeInt16LE(value, this.o);\n  }\n\n  u32(value = 0) {\n    this.o = this.b.writeUInt32LE(value, this.o);\n  }\n\n  i32(value = 0) {\n    this.o = this.b.writeInt32LE(value, this.o);\n  }\n\n  f32(value = 0) {\n    this.o = this.b.writeFloatLE(value, this.o);\n  }\n\n  u64(value = 0n) {\n    this.o = this.b.writeBigUInt64LE(BigInt(value), this.o);\n  }\n\n  i64(value = 0n) {\n    this.o = this.b.writeBigInt64LE(BigInt(value), this.o);\n  }\n\n  string(value = \"\", maxLength = 0) {\n    this.u16(value.length);\n    if (value.length <= maxLength) this.o += this.b.write(value, this.o, \"utf16le\");\n  }\n\n  /**\n   * @param opts.length Used when Buffer should be fixed length -> no header\n   * @param opts.maxLen Used when Buffer has a max number of chunk -> chunk count is written as header\n   * @param opts.lenType Required if maxLen, Used to specify header size possible values: [\"u8\", \"u16\", \"u32\"]\n   * @param opts.multiplier Default: 1, Used to specify chunk size, Buffer size should be a multiple of multiplier, defaults to 1\n   * @param opts If empty, fallback to opts.length = Buffer.length\n   */\n  bytes(\n    value = Buffer.alloc(0),\n    opts: {\n      length?: number;\n      maxLen?: number;\n      lenType?: \"u8\" | \"u16\" | \"u32\";\n      multiplier?: number;\n    } = {}\n  ) {\n    if (opts.maxLen) {\n      const chunkSize = opts.multiplier ?? 1;\n      if (value.length % chunkSize)\n        throw new Error(\n          `Error writing bytes, chunkSize should be a multiple of intut value size, got ${value.length}%${chunkSize}`\n        );\n      const count = value.length / chunkSize;\n      if (count > opts.maxLen)\n        throw new Error(`Error writing bytes, input value size exceeded maxLen, got ${count} > ${opts.maxLen}`);\n      if (!opts.lenType)\n        throw new Error(`Error writing bytes, invalid lenType when writing chunks, got ${opts.lenType}`);\n\n      this[opts.lenType](count);\n    } else if (opts.length && value.length !== opts.length) {\n      throw new Error(\n        `Error writing bytes, input value size doesn't match opts.length, ${value.length} !== ${opts.lenType}`\n      );\n    }\n    this.o += value.copy(this.b, this.o);\n\n    // TODO: minLength value for fixed length?\n    // TODO: check if this is working\n    /* if (lenType) this[lenType](value.length);\n      if (maxLength && value.length > maxLength) return;\n      if (maxLength && value.length < maxLength) value = Buffer.concat([value, Buffer.alloc(maxLength - value.length)]);\n      this.offset += value.copy(this.buf, this.offset); */\n  }\n\n  /**\n   *\n   * @param opts.maxLen Max size of array, size is set to 0 if overflow\n   * @param opts.lenTypeUsed to specify header size possible values: [\"u8\", \"u16\", \"u32\"]\n   */\n  array(\n    value: any[] = [],\n    opts: { maxLen: number; lenType: \"u8\" | \"u16\" | \"u32\" },\n    callbackfn: (...args: any[]) => any\n  ) {\n    if (value === undefined || value.length > opts.maxLen) {\n      this[opts.lenType](0);\n      return;\n    }\n    this[opts.lenType](value.length);\n    value.forEach(callbackfn);\n  }\n}\n","// Auto Generated, do not edit.\nimport type { Read } from \"../../stream\";\nexport type AbilityData = {\n  id: number;\n  level: number;\n  points: number;\n};\nexport function read(reader: Read) {\n  const data = {} as AbilityData;\n  data.id = reader.u32();\n  data.points = reader.u16();\n  data.level = reader.u8();\n  return data;\n}\n","// Auto Generated, do not edit.\nimport { Read } from \"../../stream\";\nimport * as AbilityData from \"../structures/AbilityData\";\nexport type PKTAbilityChangeNotify = {\n  abilityDataList: AbilityData.AbilityData[];\n};\nexport function read(buf: Buffer) {\n  const reader = new Read(buf);\n  const data = {} as PKTAbilityChangeNotify;\n  data.abilityDataList = reader.array(reader.u16(), () => AbilityData.read(reader), 100);\n  return data;\n}\nexport const name = \"PKTAbilityChangeNotify\";\nexport const opcode = 0;","names":["import_tiny_typed_emitter","read","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","version","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","read","version","write","read","read","name","opcode","read","read","read","read","read","read","read","read","read","read","read","read","read","name","opcode","read","read","name","opcode","read","name","opcode","read","read","version","write","read","version","write","read","read","name","opcode","read","name","opcode","read","read","read","name","opcode","read","version","write","read","version","write","read","read","name","opcode","read","read","name","opcode","read","name","opcode","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","read","name","opcode","read","name","opcode","read","name","opcode","read","version","write","read","read","read","name","opcode","read","name","opcode","read","name","opcode","read","version","write","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","name","opcode","read","opcode","name","opcode","read","version","write","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","read","version","write","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","version","write","read","version","write","name","read","version","write","name","read","write","name","read","version","write","name","read","version","write","name","read","version","write","name","name","read","write","opcode","read","logId","read","write","size","import_fs","opcode","logId","version"]}